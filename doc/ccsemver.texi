\input texinfo.tex
@c %**start of header
@setfilename ccsemver.info
@settitle CCSemver
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCSemver

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCSemver

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccsemver

@c To be used as @value{ORIGIN_AUTHOR} whenever we need to include the list of
@c authors of this document.
@set ORIGIN_AUTHOR              Lucas Abel

@c To be used as @value{ORIGIN_AUTHOR_URL} whenever we need to include the
@c email of the *single* author of this document.
@set ORIGIN_AUTHOR_URL          @email{https://github.com/uael}

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.7.1

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set ORIGIN_URL                 @url{https://github.com/uael/sv/}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing semantic versioning for the C language.

This package supports @posix{} platforms.  This package depends on the package CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}.

The package is distributed under the terms of the Unlicense, see @url{http://unlicense.org}.

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

This package is a fork of the project Libsv by @value{ORIGIN_AUTHOR}; the original project is
available at:

@center @value{ORIGIN_URL}
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{ORIGIN_AUTHOR}, @value{AUTHOR}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccsemver: (ccsemver).               CCSemver, semantic versioning for C.
@end direntry
@end ifinfo

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* semver::                      Semantic versioning.
* versions::                    Parsing version specifications.
* comparators::                 Parsing and using comparators.
* ranges::                      Parsing and using ranges.
* numbers::                     Parsing numeric components.
* identifiers::                 Parsing identifiers.
* utilities::                   Utility functions.

Appendices

* Package License::             Unlicense.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C language library
implementing semantic versioning for the C language.  We can find definition of semantic versioning
at:

@center @url{https://semver.org/}

This package supports @posix{} platforms.  This package depends on the package
@url{https://github.com/marcomaggi/ccexceptions/, CCExceptions}, at least version
@value{CCEXCEPTIONS_VERSION}.

@value{PACKAGE} installs the single header file @file{ccsemver.h}.  All the function names in the
@api{} are prefixed with @code{ccsemver_}; all the constant names are prefixed with
@code{CCSEMVER_}; all the type names are prefixed with @code{ccsemver_} and suffixed with @code{_t}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCSEMVER],[ccsemver >= 0.1])
@end example

@noindent
which will set the variables @code{CCSEMVER_LIBS} and @code{CCSEMVER_CFLAGS}.  To avoid
problems with @command{pkg-config}, we need to remember that:

@itemize
@item
The macro file defining @code{PKG_CHECK_MODULES} is installed by the package @code{pkg-config}; such
file usually is in one of the locations:

@center @file{/usr/share/aclocal/pkg.m4}
@center @file{/usr/local/share/aclocal/pkg.m4}

@item
The macro file is located by @command{aclocal}, which in turn is installed by the package @gnu{}
Automake; @command{aclocal} is used by @command{autoreconf}.  We must make sure that
@command{aclocal} finds the installed macro files; for this purpose we can use the environment
variable @env{ACLOCAL_PATH}; under a Bourne shell we can do this with:

@example
export ACLOCAL_PATH=/usr/local/share/aclocal:/usr/share/aclocal
@end example
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccsemver],[ccsemver_version_string],,
  [AC_MSG_FAILURE([test for CCSemver library failed])])
AC_CHECK_HEADERS([ccsemver.h],,
  [AC_MSG_FAILURE([test for CCSemver header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccsemver_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccsemver_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccsemver_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccsemver_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node semver
@chapter Semantic versioning


A @dfn{version} is described by the @samp{v2.0.0} specification found
at:

@center @url{http://semver.org/}

A leading @samp{v} character is stripped off and ignored.

@menu
* semver ranges::               Ranges.
* semver tags::                 Prerelease tags.
* semver advanced::             Advanced range syntax.
@end menu

@c page
@node semver ranges
@section Ranges


A @dfn{version range} is a set of @dfn{comparators} which specify
versions that satisfy the range.  A comparator is composed of an
@dfn{operator} and a @dfn{version}.  The set of primitive operators is:

@table @code
@item <
Less than.

@item <=
Less than or equal to.

@item >
Greater than.

@item >=
Greater than or equal to.

@item =
Equal.  If no operator is specified, then equality is assumed, so this
operator is optional, but MAY be included.
@end table

For example, the comparator @samp{>=1.2.7} would match the versions
@samp{1.2.7}, @samp{1.2.8}, @samp{2.5.3}, and @samp{1.3.9}, but not the
versions @samp{1.2.6} or @samp{1.1.0}.

Comparators can be joined by whitespace to form a @dfn{comparator set},
which is satisfied by the @strong{intersection} of all of the
comparators it includes.

A range is composed of one or more comparator sets, joined by @code{||}.
A version matches a range if and only if every comparator in at least
one of the @code{||}--separated comparator sets is satisfied by the
version.

For example, the range @samp{>=1.2.7 <1.3.0} would match the versions
@samp{1.2.7}, @samp{1.2.8}, and @samp{1.2.99}, but not the versions
@samp{1.2.6}, @samp{1.3.0}, or @samp{1.1.0}.

The range @samp{1.2.7 || >=1.2.9 <2.0.0} would match the versions
@samp{1.2.7}, @samp{1.2.9}, and @samp{1.4.6}, but not the versions
@samp{1.2.8} or @samp{2.0.0}.

@c page
@node semver tags
@section Prerelease tags


If a version has a prerelease tag (for example @samp{1.2.3-alpha.3})
then it will only be allowed to satisfy comparator sets if at least one
comparator with the same @code{(major, minor, patch)} tuple also has a
prerelease tag.

For example, the range @samp{>1.2.3-alpha.3} would be allowed to match
the version @samp{1.2.3-alpha.7}, but it would @strong{not} be satisfied
by @samp{3.4.5-alpha.9}, even though @samp{3.4.5-alpha.9} is technically
``greater than'' @samp{1.2.3-alpha.3} according to the Semantic
Versioning sort rules.  The version range only accepts prerelease tags
on the @samp{1.2.3} version.  The version @samp{3.4.5} @strong{would}
satisfy the range, because it does not have a prerelease tag, and
@samp{3.4.5} is greater than @samp{1.2.3-alpha.7}.

The purpose for this behavior is twofold.

@itemize
@item
Prerelease versions frequently are updated very quickly, and contain
many breaking changes that are (by the author's design) not yet fit for
public consumption.  Therefore, by default, they are excluded from range
matching semantics.

@item
A user who has opted into using a prerelease version has clearly
indicated the intent to use @strong{that specific} set of alpha/beta/rc
versions.  By including a prerelease tag in the range, the user is
indicating that they are aware of the risk.  However, it is still not
appropriate to assume that they have opted into taking a similar risk on
the @strong{next} set of prerelease versions.
@end itemize

@c page
@node semver advanced
@section Advanced range syntax


Advanced range syntax desugars to primitive comparators in deterministic
ways.  Advanced ranges may be combined in the same way as primitive
comparators using white space or @code{||}.

@c ------------------------------------------------------------------------

@subsubheading Hyphen ranges @samp{X.Y.Z - A.B.C}


Specifies an inclusive set.

@table @asis
@item @samp{1.2.3 - 2.3.4} := @samp{>=1.2.3 <=2.3.4}
@end table

If a partial version is provided as the first version in the inclusive
range, then the missing pieces are replaced with zeroes.

@table @asis
@item @samp{1.2 - 2.3.4} := @samp{>=1.2.0 <=2.3.4}
@end table

If a partial version is provided as the second version in the inclusive
range, then all versions that start with the supplied parts of the tuple
are accepted, but nothing that would be greater than the provided tuple
parts.

@table @asis
@item @samp{1.2.3 - 2.3} := @samp{>=1.2.3 <2.4.0}

@item @samp{1.2.3 - 2} := @samp{>=1.2.3 <3.0.0}
@end table

@c ------------------------------------------------------------------------

@subsubheading X-Ranges @samp{1.2.x} @samp{1.X} @samp{1.2.*} @samp{*}


Any of @samp{X}, @samp{x}, or @samp{*} may be used to ``stand in'' for
one of the numeric values in the @code{(major, minor, patch)} tuple.

@table @asis
@item @samp{*} := @samp{>=0.0.0}
Any version satisfies.

@item @samp{1.x} := @samp{>=1.0.0 <2.0.0}
Matching major version.

@item @samp{1.2.x} := @samp{>=1.2.0 <1.3.0}
Matching major and minor versions.
@end table

A partial version range is treated as an X-Range, so the special
character is in fact optional.

@table @asis
@item Empty string := @samp{*} := @samp{>=0.0.0}

@item @samp{1} := @samp{1.x.x} := @samp{>=1.0.0 <2.0.0}

@item @samp{1.2} := @samp{1.2.x} := @samp{>=1.2.0 <1.3.0}
@end table

@c ------------------------------------------------------------------------

@subsubheading Tilde ranges @samp{~1.2.3} @samp{~1.2} @samp{~1}

Allows patch--level changes if a minor version is specified on the
comparator.  Allows minor-level changes if not.

@table @asis
@item @samp{~1.2.3} := @samp{>=1.2.3 <1.(2+1).0} := @samp{>=1.2.3 <1.3.0}

@item @samp{~1.2} := @samp{>=1.2.0 <1.(2+1).0} := @samp{>=1.2.0 <1.3.0}
Same as @samp{1.2.x}.

@item @samp{~1} := @samp{>=1.0.0 <(1+1).0.0} := @samp{>=1.0.0 <2.0.0}
Same as @samp{1.x}.

@item @samp{~0.2.3} := @samp{>=0.2.3 <0.(2+1).0} := @samp{>=0.2.3 <0.3.0}

@item @samp{~0.2} := @samp{>=0.2.0 <0.(2+1).0} := @samp{>=0.2.0 <0.3.0}
Same as @samp{0.2.x}.

@item @samp{~0} := @samp{>=0.0.0 <(0+1).0.0} := @samp{>=0.0.0 <1.0.0}
Same as @samp{0.x}.

@item @samp{~1.2.3-beta.2} := @samp{>=1.2.3-beta.2 <1.3.0}
Note that prereleases in the @samp{1.2.3} version will be allowed, if
they are greater than or equal to @samp{beta.2}.  So,
@samp{1.2.3-beta.4} would be allowed, but @samp{1.2.4-beta.2} would not,
because it is a prerelease of a different @code{(major, minor, patch)}
tuple.
@end table

@c ------------------------------------------------------------------------

@subsubheading Caret ranges @samp{^1.2.3} @samp{^0.2.5} @samp{^0.0.4}


Allow changes that do not modify the left--most non--zero digit in the
@code{(major, minor, patch)} tuple.  In other words, this allows patch
and minor updates for versions @samp{1.0.0} and above, patch updates for
versions @samp{0.X >=0.1.0}, and @strong{no} updates for versions
@samp{0.0.X}.

Many authors treat a @samp{0.x} version as if the @samp{x} were the
major ``breaking change'' indicator.

Caret ranges are ideal when an author may make breaking changes between
@samp{0.2.4} and @samp{0.3.0} releases, which is a common practice.
However, it presumes that there will @strong{not} be breaking changes
between @samp{0.2.4} and @samp{0.2.5}.  It allows for changes that are
presumed to be additive (but non--breaking), according to commonly
observed practices.

@table @asis
@item @samp{^1.2.3} := @samp{>=1.2.3 <2.0.0}

@item @samp{^0.2.3} := @samp{>=0.2.3 <0.3.0}

@item @samp{^0.0.3} := @samp{>=0.0.3 <0.0.4}

@item @samp{^1.2.3-beta.2} := @samp{>=1.2.3-beta.2 <2.0.0}
Note that prereleases in the @samp{1.2.3} version will be allowed, if
they are greater than or equal to @samp{beta.2}.  So,
@samp{1.2.3-beta.4} would be allowed, but @samp{1.2.4-beta.2} would not,
because it is a prerelease of a different @code{(major, minor, patch)}
tuple.

@item @samp{^0.0.3-beta} := @samp{>=0.0.3-beta <0.0.4}
Note that prereleases in the @samp{0.0.3} version @strong{only} will be
allowed, if they are greater than or equal to @samp{beta}.  So,
@samp{0.0.3-pr.2} would be allowed.
@end table

When parsing caret ranges, a missing @code{patch} value desugars to the
number @samp{0}, but will allow flexibility within that value, even if
the major and minor versions are both @samp{0}.

@table @asis
@item @samp{^1.2.x} := @samp{>=1.2.0 <2.0.0}

@item @samp{^0.0.x} := @samp{>=0.0.0 <0.1.0}

@item @samp{^0.0} := @samp{>=0.0.0 <0.1.0}
@end table

A missing @code{minor} and @code{patch} values will desugar to zero, but
also allow flexibility within those values, even if the major version is
zero.

@table @asis
@item @samp{^1.x} := @samp{>=1.0.0 <2.0.0}

@item @samp{^0.x} := @samp{>=0.0.0 <1.0.0}
@end table

@c page
@node versions
@chapter Parsing version specifications


The versions @api{} does @strong{not} duplicate the input strings.

@menu
* versions typedefs::           Type definitions.
* versions reading::            Parsing from a string.
* versions writing::            Writing to a string.
* versions comparing::          Versions comparison.
@end menu

@c page
@node versions typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_t
Type of data structures representing parsed versions.  Instances of this structure are initialised
with @cfunc{ccsemver_init} or @cfunc{ccsemver_new}.  Instances of this structure are finalised with
@cfunc{ccsemver_delete}.

It has the following public fields:

@table @code
@item long major
An integer representing the major version number.

@item long minor
An integer representing the minor version number.

@item long patch
An integer representing the patch level.

@item ccsemver_id_t prerelease
An identifier representing the prerelease tag.

@item ccsemver_id_t build
An identifier representing the build metadata.

@item size_t len
The number of characters in the input string that where parsed to form this version.

@item const char * raw
Pointer to the character in the input string representing the first character of this component.
This pointer is valid as long as the input string handed to the constructor function is not mutated.
@end table
@end deftp


@deftypefun void ccsemver_ctor (ccsemver_t * @var{versionp})
Initialise to empty an already allocated data structure representing a
parsed version.  Every call to this function must be matched by a call
to @cfunc{ccsemver_dtor}:

@example
ccsemver_t        version;

ccsemver_ctor(&version);
@{
  /* Do something with "version" here. */
@}
ccsemver_dtor(&version);
@end example
@end deftypefun


@deftypefun void ccsemver_dtor (ccsemver_t * @var{versionp})
Finalise to empty a data structure representing a parsed version; calls
to this function must match a previous call to @cfunc{ccsemver_ctor} or
@cfunc{ccsemver_read}.

All the resources associated to @var{versionp} are released, but the
structure itself.  The following code is correct:

@example
ccsemver_t        version;

ccsemver_ctor(&version);
@{
  /* Do something with "version" here. */
@}
ccsemver_dtor(&version);
@end example

@noindent
the following code is also correct:

@example
ccsemver_t *      versionp;

versionp = malloc(sizeof(ccsemver_t));
assert(NULL != versionp);
@{
  ccsemver_ctor(versionp);
  @{
    /* Do something with "versionp" here. */
  @}
  ccsemver_dtor(versionp);
@}
free(versionp);
@end example
@end deftypefun

@c page
@node versions reading
@section Parsing from a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_read (ccsemver_t * @var{versionp}, const char * @var{input_buf}, size_t @var{input_len}, size_t * @var{input_offp})
Parse an input string in @ascii{} format which is meant to hold a
version specification.  When successful: the return value is @code{0}.
If an error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure
referenced by @var{versionp}; the structure is first initialised with
@cfunc{ccsemver_ctor}.

In both the successful and unsuccessful cases: every call to this
function must be matched by the application of @cfunc{ccsemver_dtor} to
@var{versionp}.

The input string is referenced by @var{input_buf}; the length of the
input string is @var{input_len} characters.  The argument
@var{input_offp} is both an input and output parameter:

@itemize
@item
Upon entering the function: the offset of the first character to parse
in @var{input_buf} is acquired from the variable referenced by
@var{input_offp}.

@item
When the function returns successfully: the offset of the first
non--parsed character is stored in the variable referenced by
@var{input_offp}; further parsing operations can use such value as
input.

@item
When the function returns unsuccessfully: the value stored in the
variable is invalid.
@end itemize

If the string is empty (@var{input_len} is zero): the function returns
unsuccessfully.

Internally, this function allocates memory with @cfunc{malloc}; if
memory allocation fails: the return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a numeric version

The following example parses the numeric version @samp{1.2.3}:

@example
char const    input_str[] = "1.2.3";
ccsemver_t      version;
size_t        input_off = 0;
char          rv;

rv = ccsemver_read(&version, input_str, strlen(input_str), &input_off);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         version.major, version.minor, version.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&version.prerelease, stdout);
  printf(", ");
  printf("build=");
  ccsemver_id_fwrite(&version.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&version);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=, build=
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a tagged version

The following example parses the version @samp{1.2.3-alpha.7}, which has
a prerelease tag:

@example
char const    input_str[] = "1.2.3-alpha.7";
ccsemver_t      version;
size_t        input_off = 0;
char          rv;

rv = ccsemver_read(&version, input_str, strlen(input_str), &input_off);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         version.major, version.minor, version.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&version.prerelease, stdout);
  printf(", ");
  printf("build=");
  ccsemver_id_fwrite(&version.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&version);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=alpha.7, build=
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a full version

The following example parses the version @samp{1.2.3-alpha.7+x86-64},
which has both a prerelease tag and build metadata:

@example
char const    input_str[] = "1.2.3-alpha.7+x86-64";
ccsemver_t      version;
size_t        input_off = 0;
char          rv;

rv = ccsemver_read(&version, input_str, strlen(input_str), &input_off);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         version.major, version.minor, version.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&version.prerelease, stdout);
  printf(", ");
  printf("build=");
  ccsemver_id_fwrite(&version.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&version);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=alpha.7, build=x86-64
@end example

@c page
@node versions writing
@section Writing to a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun int ccsemver_write (ccsemver_t const * @var{versionp}, char * @var{output_buf}, size_t @var{output_len})
Serialise the version @var{versionp} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full version serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold
the full serialisation, excluding the trailing null; if the return value
is greater than or equal to @var{output_len}, the string has been
truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a version

The following example serialises a version specification:

@example
static const char     input_str[] = "1.2.3-alpha.7";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_t      version;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_read(&version, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_write(&version, \
     buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
        needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, id=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
len=13, actual_count=13, id=1.2.3-alpha.7
@end example

@c page
@node versions comparing
@section Versions comparison


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_comp (ccsemver_t const * @var{A}, ccsemver_t const * @var{B})
Compare the given versions.  Return @code{-1} if @var{A} is less than
@var{B}; return @code{0} if @var{A} is equal to @var{B}; return
@code{+1} if @var{A} is greater than @var{B}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: comparing versions


The following example compares two versions:

@example
static const char     input_str_A[] = "1.2.3";
static const char     input_str_B[] = "1.2.4";
ccsemver_t      version_A, version_B;
size_t        offset_A = 0, offset_B = 0;
char          rv;

rv = ccsemver_read(&version_A, input_str_A,
                   strlen(input_str_A), &offset_A);
if (0 == rv) @{
  rv = ccsemver_read(&version_B, input_str_B,
                   strlen(input_str_B), &offset_B);
  if (0 == rv) @{
    char    compar = ccsemver_comp(&version_A, &version_B);
    printf("compar=%d\n", (int)compar);
  @}
  ccsemver_dtor(&version_B);
@}
ccsemver_dtor(&version_A);
@end example

@noindent
and the code prints:

@example
compar=-1
@end example

@c page
@node comparators
@chapter Parsing and using comparators


The comparators @api{} does @strong{not} duplicate the input strings.

@menu
* comparators constants::       Constants definitions.
* comparators typedefs::        Type definitions.
* comparators reading::         Parsing from a string.
* comparators writing::         Writing to a string.
* comparators matching::        Matching with versions.
@end menu

@c page
@node comparators constants
@section Constants definitions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftp {Enumeration} ccsemver_op
Type of enumeration representing the comparison criteria for
comparators.
@end deftp


@deftypevr {Enumerated Constant} {enum ccsemver_op} CCSEMVER_OP_EQ
Represent the ``equality'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} {enum ccsemver_op} CCSEMVER_OP_LT
Represent the ``less than'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} {enum ccsemver_op} CCSEMVER_OP_LE
Represent the ``less than or equal to'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} {enum ccsemver_op} CCSEMVER_OP_GT
Represent the ``greater than'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} {enum ccsemver_op} CCSEMVER_OP_GE
Represent the ``greater than or equal to'' operator.
@end deftypevr

@c page
@node comparators typedefs
@section Type definitions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_comp_t
Type of data structures representing parsed comparators.  Every instance
of this structure is a node in a simply--linked list.  Instances of this
structure are initialised with @cfunc{ccsemver_comp_ctor} or
@cfunc{ccsemver_comp_read}.  Instances of this structure are finalised
with @cfunc{ccsemver_comp_dtor}.

It has the following public fields:

@table @code
@item ccsemver_comp_t * next
Pointer to the next comparator in the linked list; @cnull{} if this
instance is the last in the list.

@item enum ccsemver_op op
The operator specification for this comparator.

@item ccsemver_t version
The version specification for this comparator.
@end table
@end deftp


@deftypefun void ccsemver_comp_ctor (ccsemver_comp_t * @var{compp})
Initialise to empty an already allocated data structure representing a
parsed comparator.  Every call to this function must be matched by a
call to @cfunc{ccsemver_comp_dtor}:

@example
ccsemver_comp_t   comp;

ccsemver_comp_ctor(&comp);
@{
  /* Do something with "comp" here. */
@}
ccsemver_comp_dtor(&comp);
@end example
@end deftypefun


@deftypefun void ccsemver_comp_dtor (ccsemver_comp_t * @var{compp})
Finalise to empty a data structure representing a parsed comparator;
calls to this function must match a previous call to
@cfunc{ccsemver_comp_ctor} or @cfunc{ccsemver_comp_read}.

All the resources associated to @var{compp} are released, but the
structure itself.  The following code is correct:

@example
ccsemver_comp_t   comp;

ccsemver_comp_ctor(&comp);
@{
  /* Do something with "comp" here. */
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
the following code is also correct:

@example
ccsemver_comp_t * compp;

compp = malloc(sizeof(ccsemver_comp_t));
assert(NULL != compp);
@{
  ccsemver_comp_ctor(compp);
  @{
    /* Do something with "compp" here. */
  @}
  ccsemver_comp_dtor(compp);
@}
free(compp);
@end example
@end deftypefun

@c page
@node comparators reading
@section Parsing from a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_comp_read (ccsemver_comp_t * @var{compp}, const char * @var{input_buf}, size_t @var{input_len}, size_t * @var{input_offp})
Parse an input string in @ascii{} format which is meant to hold a
comparator specification.  When successful: the return value is
@code{0}.  If an error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure
referenced by @var{compp}; the structure is first initialised with
@cfunc{ccsemver_comp_ctor}.

In both the successful and unsuccessful cases: every call to this
function must be matched by the application of @cfunc{ccsemver_comp_dtor}
to @var{compp}.

The input string is referenced by @var{input_buf}; the length of the
input string is @var{input_len} characters.  The argument
@var{input_offp} is both an input and output parameter:

@itemize
@item
Upon entering the function: the offset of the first character to parse
in @var{input_buf} is acquired from the variable referenced by
@var{input_offp}.

@item
When the function returns successfully: the offset of the first
non--parsed character is stored in the variable referenced by
@var{input_offp}; further parsing operations can use such value as
input.

@item
When the function returns unsuccessfully: the value stored in the
variable is invalid.
@end itemize

If the string is empty (@var{input_len} is zero): the function returns
unsuccessfully.

Internally, this function allocates memory with @cfunc{malloc}; if
memory allocation fails: the return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun char ccsemver_comp_and (ccsemver_comp_t * @var{compp}, const char * @var{input_buf}, size_t @var{input_len}, size_t * @var{input_offp})
Parse an input string in @ascii{} format which is meant to hold a
comparator specification.  When successful: the return value is
@code{0}.  If an error occurs: the return value is @code{1}.

The results of parsing are appended to the already allocated and built
structure referenced by @var{compp}.

In the unsuccessful case: the structure referenced by @var{compp} is
left untouched.

The meaning of the arguments @var{input_buf}, @var{input_len} and
@var{input_offp} is the same as in @cfunc{ccsemver_comp_read}.

If the string is empty (@var{input_len} is zero): the function returns
unsuccessfully.

Internally, this function allocates memory with @cfunc{malloc}; if
memory allocation fails: the return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a comparator

The following example parses the comparator specification
@samp{<=1.2.3}:

@example
static const char     input_str[] = "<=1.2.3";
ccsemver_comp_t comp;
size_t        offset = 0;
char          rv;

rv = ccsemver_comp_read(&comp, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("operation=%s, ", ccsemver_op_string(comp.op));
  ccsemver_fwrite(&comp.version, stdout);
  printf("\n");
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
and it prints:

@example
operation=CCSEMVER_OP_LE, 1.2.3
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: extending a comparator

The following example parses the comparator specification
@samp{<=1.2.3} and then extends it with @samp{<3.0.0}:

@example
static const char     input_str_1[] = ">=1.2.3";
static const char     input_str_2[] = "<3.0.0";
ccsemver_comp_t comp;
size_t        offset_1 = 0;
size_t        offset_2 = 0;
char          rv;

rv = ccsemver_comp_read(&comp, \
        input_str_1, strlen(input_str_1), &offset_1);
if (0 == rv) @{
  rv = ccsemver_comp_and(&comp, \
          input_str_2, strlen(input_str_2), &offset_2);
  if (0 == rv) @{
    for (ccsemver_comp_t * it = &comp; it; it = it->next) @{
      printf("operation=%s, ", ccsemver_op_string(it->op));
      ccsemver_fwrite(&(it->version), stdout);
      printf("\n");
    @}
    printf("comparator: ");
    ccsemver_comp_fwrite(&comp, stdout);
    printf("\n");
  @}
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
and it prints:

@example
operation=CCSEMVER_OP_GE, 1.2.3
operation=CCSEMVER_OP_LT, 3.0.0
comparator: >=1.2.3 <3.0.0
@end example

@c page
@node comparators writing
@section Writing to a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun int ccsemver_comp_write (ccsemver_comp_t const * @var{compp}, char * @var{output_buf}, size_t @var{output_len})
Serialise the comparator @var{compp} as @ascii{} string in the memory
block referenced by @var{output_buf}, which has at least
@var{output_len} characters available.  If the buffer has not enough
room to hold the full comparator serialisation: the string is truncated
to @var{output_len} characters.

Like @cfunc{snprintf}: return the number of characters needed to hold
the full serialisation, excluding the trailing null; if the return value
is greater than or equal to @var{output_len}, the string has been
truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a comparator


The following example serialises a comparator:

@example
static const char     input_str[] = "<=1.2.3";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_comp_t comp;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_comp_read(&comp, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_comp_write(&comp, \
                    buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
                       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, comp=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
the code prints:

@example
len=7, actual_count=7, comp=<=1.2.3
@end example

@c page
@node comparators matching
@section Matching with versions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_match (ccsemver_t const * @var{versionp}, ccsemver_comp_t const * @var{compp})
Match a version referenced by @var{versionp} against all the comparators
in the linked list referenced by @var{compp}.  The return value is
@code{1} if the version matches; it is @code{0} otherwise.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: matching a version


The following example matches a version against a standalone comparator:

@example
const char      version_str[] = "1.2.3";
const char      compar_str[]  = ">=2.0.0";
ccsemver_t      version;
ccsemver_comp_t comp;
size_t          version_off = 0, comp_off = 0;
char            rv;

rv = ccsemver_read(&version, \
        version_str, strlen(version_str), &version_off);
if (0 == rv) @{
  rv = ccsemver_comp_read(&comp, \
          compar_str, strlen(compar_str), &comp_off);
  if (0 == rv) @{
    int       result = (int)ccsemver_match(&version, &comp);
    printf("matches?=%s\n", (result)? "yes" : "no");
  @}
  ccsemver_comp_dtor(&comp);
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
matches?=no
@end example

@c page
@node ranges
@chapter Parsing and using ranges


The ranges @api{} does @strong{not} duplicate the input strings.

@menu
* ranges typedefs::             Type definitions.
* ranges reading::              Parsing from a string.
* ranges writing::              Writing to a string.
* ranges matching::             Matching ranges and versions.
@end menu

@c page
@node ranges typedefs
@section Type definitions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_range_t
Type of data structures representing parsed ranges; a range is a set of
comparators.  Every instance of this structure is a node in a
simply--linked list.  Instances of this structure are initialised with
@cfunc{ccsemver_range_read}.  Instances of this structure are finalised
with @cfunc{ccsemver_range_dtor}.

It has the following public fields:

@table @code
@item ccsemver_range_t * next
Pointer to the next structure in the linked list; @cnull{} if this
instance is the last in the list.

@item ccsemver_comp_t comp
A version comparator.
@end table
@end deftp


@deftypefun void ccsemver_range_dtor (ccsemver_range_t * @var{rangep})
Finalise to empty a data structure representing a parsed range; calls to
this function must match a previous call to @cfunc{ccsemver_range_read}.

All the resources associated to @var{rangep} are released, but the
structure itself.  The following code is correct:

@example
ccsemver_range_t  range;

ccsemver_range_read(&range, ...);
@{
  /* Do something with "range" here. */
@}
ccsemver_range_dtor(&range);
@end example

@noindent
the following code is also correct:

@example
ccsemver_range_t * rangep;

rangep = malloc(sizeof(ccsemver_range_t));
assert(NULL != rangep);
@{
  ccsemver_range_read(&range, ...);
  @{
    /* Do something with "rangep" here. */
  @}
  ccsemver_range_dtor(rangep);
@}
free(rangep);
@end example
@end deftypefun

@c page
@node ranges reading
@section Parsing from a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_range_read (ccsemver_range_t * @var{rangep}, const char * @var{input_buf}, size_t @var{input_len}, size_t * @var{input_offp})
Parse an input string in @ascii{} format which is meant to hold a range
specification.  When successful: the return value is @code{0}.  If an
error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure
referenced by @var{rangep}.

In both the successful and unsuccessful cases: every call to this
function must be matched by the application of @cfunc{ccsemver_range_dtor}
to @var{rangep}.

The input string is referenced by @var{input_buf}; the length of the
input string is @var{input_len} characters.  The argument
@var{input_offp} is both an input and output parameter:

@itemize
@item
Upon entering the function: the offset of the first character to parse
in @var{input_buf} is acquired from the variable referenced by
@var{input_offp}.

@item
When the function returns successfully: the offset of the first
non--parsed character is stored in the variable referenced by
@var{input_offp}; further parsing operations can use such value as
input.

@item
When the function returns unsuccessfully: the value stored in the
variable is invalid.
@end itemize

If the string is empty (@var{input_len} is zero): the function returns
unsuccessfully.

Internally, this function allocates memory with @cfunc{malloc}; if
memory allocation fails: the return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a range

The following example parses the range specification
@samp{1.2.7 || >=1.2.9 <2.0.0}:

@example
static const char  input_str[] = "1.2.7 || >=1.2.9 <2.0.0";
ccsemver_range_t     range;
size_t             offset = 0;
char               rv;

rv = ccsemver_range_read(&range, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("range: ");
  ccsemver_range_fwrite(&range, stdout);
  printf("\n");
@}
ccsemver_range_dtor(&range);
@end example

@noindent
and it prints:

@example
range: 1.2.7 || >=1.2.9 <2.0.0
@end example

@c page
@node ranges writing
@section Writing to a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun int ccsemver_range_write (ccsemver_range_t const * @var{rangep}, char * @var{output_buf}, size_t @var{output_len})
Serialise the range @var{rangep} as @ascii{} string in the memory block
referenced by @var{output_buf}, which has at least @var{output_len}
characters available.  If the buffer has not enough room to hold the
full comparator serialisation: the string is truncated to
@var{output_len} characters.

Like @cfunc{snprintf}: return the number of characters needed to hold
the full serialisation, excluding the trailing null; if the return value
is greater than or equal to @var{output_len}, the string has been
truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a range


The following example serialises a range:

@example
static const char     input_str[] = \
   "1.2.7 || >=1.2.9 <2.0.0";
size_t                buffer_len = 32;
char                  buffer_ptr[buffer_len];
ccsemver_range_t        range;
size_t                offset = 0;
char                  rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_range_read(&range, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_range_write(&range, \
     buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, range=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_range_dtor(&range);
@end example

@noindent
the code prints:

@example
len=23, actual_count=23, range=1.2.7 || >=1.2.9 <2.0.0
@end example

@c page
@node ranges matching
@section Matching ranges and versions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_range_match (ccsemver_t const * @var{versionp}, ccsemver_range_t const * @var{rangep})
Match a version referenced by @var{versionp} against the comparators in
the range referenced by @var{rangep}.  The return value is @code{1} if
the version matches; it is @code{0} otherwise.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: matching a version


The following example matches a version against a range:

@example
static const char     version_str[] = "1.4.6";
static const char     range_str[]  = "1.2.7 || >=1.2.9 <2.0.0";
ccsemver_t              version;
ccsemver_range_t        range;
size_t                version_off = 0, range_off = 0;
char                  rv;

rv = ccsemver_read(&version, \
        version_str, strlen(version_str), &version_off);
if (0 == rv) @{
  rv = ccsemver_range_read(&range, \
          range_str, strlen(range_str), &range_off);
  if (0 == rv) @{
    int       result = (int)ccsemver_range_match(&version, &range);
    printf("matches?=%s\n", (result)? "yes" : "no");
  @}
  ccsemver_range_dtor(&range);
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
matches?=yes
@end example

@c page
@node numbers
@chapter Parsing numeric components


In the context of @value{PACKAGE}'s parsing functions, @dfn{numeric components} are @ascii{} strings
holding: numeric characters (according to the standard function @cfunc{isdigit}); the standalone
character @samp{x}; the standalone character @samp{X}; the standalone character @samp{*}.

Usually we do @strong{not} need to use the numeric components parser directly.

All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_num_read (long * @var{nump}, const char * @var{input_buf}, size_t @var{input_len}, size_t * @var{input_offp})
Parse an input string in @ascii{} format which is meant to hold a numeric component.  When
successful: the return value is @code{0}.  If an error occurs: the return value is @code{1}.

The results of parsing are stored in the variable referenced by @var{nump}.

The input string is referenced by @var{input_buf}; the length of the input string is @var{input_len}
characters.  The argument @var{input_offp} is both an input and output parameter:

@itemize
@item
Upon entering the function: the offset of the first character to parse in @var{input_buf} is
acquired from the variable referenced by @var{input_offp}.  If the value in the referenced variable
is greater than @var{input_len}: the function returns unsuccessfully.

@item
When the function returns successfully: the offset of the first non--parsed character is stored in
the variable referenced by @var{input_offp}; further parsing operations can use such value as input.

@item
When the function returns unsuccessfully: the value stored in the variable is invalid.
@end itemize

If the string is empty (@var{input_len} is zero): the function returns successfully and stores zero
in the variable referenced by @var{nump}.

If the input string contains @samp{x}, @samp{X} or @samp{*}: the function returns successfully and
stores the value @code{CCSEMVER_NUM_X} in the variable referenced by @var{nump}.

The following example code parses a numeric component:

@example
char const *    input_str = "123";
size_t          input_len = strlen(input_str);
long            num;
size_t          input_off = 0;
char            rv;

rv = ccsemver_num_read(&num, input_str, input_len, &input_off);
if (0 == rv) @{
  printf("num=%ld\n", num);
@}
@end example
@end deftypefun


@deftypevr {Preprocessor Symbol} long CCSEMVER_NUM_X
Special value used to represent a numeric component specified as @samp{x}, @samp{X} or @samp{*}.
@end deftypevr


@deftypefun char ccsemver_num_comp (long @var{A}, long @var{B})
Compare the given integers.  Return @code{-1} if @var{A} is less than @var{B}; return @code{0} if
@var{A} is equal to @var{B}; return @code{+1} if @var{A} is greater than @var{B}.

The return values of this function are @strong{invalid} if one of the arguments is
@code{CCSEMVER_NUM_X}.
@end deftypefun

@c page
@node identifiers
@chapter Parsing identifiers


In the context of @value{PACKAGE}'s parsing functions, identifiers are
@ascii{} strings holding: alphanumeric characters (according to the
standard function @cfunc{isalnum}); dash characters; dot characters.
Dot characters are interpreted as separators between components.

The identifiers @api{} does @strong{not} duplicate the input strings.

Usually we do @strong{not} need to use the identifiers parser directly.

@menu
* identifiers typedefs::        Type definitions.
* identifiers reading::         Parsing from a string.
* identifiers writing::         Writing to a string.
* identifiers comparing::       Identifiers comparison.
@end menu

@c page
@node identifiers typedefs
@section Type definitions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_id_t
Type of data structures representing a single component in a parsed
identifier; every instance of this structure is a node in a
simply--linked list.  Instances of this structure are initialised with
@cfunc{ccsemver_id_ctor} or @cfunc{ccsemver_id_read}.  Instances of this
structure are finalised with @cfunc{ccsemver_id_dtor}.

The structure has the following public fields:

@table @code
@item bool numeric
A boolean value: @ctrue{} if the this component is numeric; @cfalse{} if
this component is alphabetic.

@item long num
If this component is numeric: this field holds its numeric
representation.  Otherwise this field holds a meaningless value.

@item size_t len
The number of characters in the input string that where parsed to form
this component.

@item const char * raw
Pointer to the character in the input string representing the first
character of this component.  This pointer is valid as long as the input
string handed to @cfunc{ccsemver_id_read} is not mutated.

@item ccsemver_id_t * next
Pointer to the next node in the linked list; @cnull{} if this structure
is the last node.
@end table
@end deftp


@deftypefun void ccsemver_id_ctor (ccsemver_id_t * @var{idp})
Initialise to empty an already allocated data structure representing a
parsed identifier.  Every call to this function must be matched by a
call to @cfunc{ccsemver_id_dtor}:

@example
ccsemver_id_t     id;

ccsemver_id_ctor(&id);
@{
  /* Do something with "id" here. */
@}
ccsemver_id_dtor(&id);
@end example
@end deftypefun


@deftypefun void ccsemver_id_dtor(ccsemver_id_t * @var{idp})
Finalise to empty a data structure representing a parsed identifier;
calls to this function must match a previous call to
@cfunc{ccsemver_id_ctor} or @cfunc{ccsemver_id_read}.

All the resources associated to @var{idp} are released, but the
structure itself.  The following code is correct:

@example
ccsemver_id_t     id;

ccsemver_id_ctor(&id);
@{
  /* Do something with "id" here. */
@}
ccsemver_id_dtor(&id);
@end example

@noindent
the following code is also correct:

@example
ccsemver_id_t *   idp;

idp = malloc(sizeof(ccsemver_id_t));
assert(NULL != idp);
@{
  ccsemver_id_ctor(idp);
  @{
    /* Do something with "idp" here. */
  @}
  ccsemver_id_dtor(idp);
@}
free(idp);
@end example
@end deftypefun

@c page
@node identifiers reading
@section Parsing from a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_id_read (ccsemver_id_t * @var{idp}, const char * @var{input_buf}, size_t @var{input_len}, size_t * @var{input_offp})
Parse an input string in @ascii{} format which is meant to hold an
identifier.  When successful: the return value is @code{0}.  If an error
occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure
referenced by @var{idp}; the structure is first initialised with
@cfunc{ccsemver_id_ctor}.

In both the successful and unsuccessful cases: every call to this
function must be matched by the application of @cfunc{ccsemver_id_dtor} to
@var{idp}.

The input string is referenced by @var{input_buf}; the length of the
input string is @var{input_len} characters.  The argument
@var{input_offp} is both an input and output parameter:

@itemize
@item
Upon entering the function: the offset of the first character to parse
in @var{input_buf} is acquired from the variable referenced by
@var{input_offp}.

@item
When the function returns successfully: the offset of the first
non--parsed character is stored in the variable referenced by
@var{input_offp}; further parsing operations can use such value as
input.

@item
When the function returns unsuccessfully: the value stored in the
variable is invalid.
@end itemize

If the string is empty (@var{input_len} is zero): the function returns
unsuccessfully.

Internally, this function allocates memory with @cfunc{malloc}; if
memory allocation fails: the return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a numeric identifier

The following example parses the numeric identifier @samp{123}:

@example
static const char     input_str[] = "123";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("numeric?=%d, num=%ld, len=%lu, raw=%s, next=%p\n",
         (int)id.numeric, id.num, id.len, id.raw,
         (void *)id.next);
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=1, num=123, len=3, raw=123, next=(nil)
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing an alphabetic identifier

The following example parses the alphabetic identifier @samp{alpha}:

@example
static const char     input_str[] = "alpha";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("numeric?=%d, num=%ld, len=%lu, raw=%s, next=%p\n",
         (int)id.numeric, id.num, id.len, id.raw,
         (void *)id.next);
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha, next=(nil)
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a compound identifier

The following example parses the compound identifier @samp{1.2.3-alpha.7}:

@example
static const char     input_str[] = "1.2.3-alpha.7";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  for (ccsemver_id_t * iter = &id; iter; iter = iter->next) @{
    printf("numeric?=%d, num=%ld, len=%lu, raw=%s\n",
           (int)iter->numeric, iter->num, iter->len, iter->raw);
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=1, num=1, len=1, raw=1.2.3-alpha.7
numeric?=1, num=2, len=1, raw=2.3-alpha.7
numeric?=0, num=0, len=7, raw=3-alpha.7
numeric?=1, num=7, len=1, raw=7
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a compound identifier with build metadata

The following example parses the compound identifier
@samp{1.2.3-alpha.7+x86-64}:

@example
static const char     input_str[] = "1.2.3-alpha.7+x86-64";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  for (ccsemver_id_t * iter = &id; iter; iter = iter->next) @{
    printf("numeric?=%d, num=%ld, len=%lu, raw=%s\n",
           (int)iter->numeric, iter->num, iter->len, iter->raw);
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=1, num=1, len=1, raw=1.2.3-alpha.7+x86-64
numeric?=1, num=2, len=1, raw=2.3-alpha.7+x86-64
numeric?=0, num=0, len=7, raw=3-alpha.7+x86-64
numeric?=1, num=7, len=1, raw=7+x86-64
@end example

@c page
@node identifiers writing
@section Writing to a string


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun int ccsemver_id_write (ccsemver_id_t const * @var{idp}, char * @var{output_buf}, size_t @var{output_len})
Serialise the identifier @var{idp} as @ascii{} string in the memory
block referenced by @var{output_buf}, which has at least
@var{output_len} characters available.  If the buffer has not enough
room to hold the full identifier serialisation: the string is truncated
to @var{output_len} characters.

Like @cfunc{snprintf}: return the number of characters needed to hold
the full serialisation, excluding the trailing null; if the return value
is greater than or equal to @var{output_len}, the string has been
truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising an identifier


The following example serialises a compound identifier:

@example
static const char     input_str[] = "1.2.3-alpha.7";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_id_write(&id, \
      buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, id=",
      strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
the code prints:

@example
len=13, actual_count=13, id=1.2.3-alpha.7
@end example

@c page
@node identifiers comparing
@section Identifiers comparison


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun char ccsemver_id_comp (ccsemver_id_t const * @var{A}, ccsemver_id_t const * @var{B})
Compare the numeric components of the given identifiers.  Return
@code{-1} if @var{A} is less than @var{B}; return @code{0} if @var{A} is
equal to @var{B}; return @code{+1} if @var{A} is greater than @var{B}.

An empty identifier is less than any other identifier but the empty one;
two empty identifiers are equal.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: comparing identifiers


The following example compares two identifiers:

@example
static const char     input_str_A[] = "1.2.3";
static const char     input_str_B[] = "1.2.4";
ccsemver_id_t   id_A, id_B;
size_t        offset_A = 0, offset_B = 0;
char          rv;

rv = ccsemver_id_read(&id_A, \
    input_str_A, strlen(input_str_A), &offset_A);
if (0 == rv) @{
  rv = ccsemver_id_read(&id_B, \
      input_str_B, strlen(input_str_B), &offset_B);
  if (0 == rv) @{
    char    compar = ccsemver_id_comp(&id_A, &id_B);
    printf("compar=%d\n", (int)compar);
  @}
  ccsemver_id_dtor(&id_B);
@}
ccsemver_id_dtor(&id_A);
@end example

@noindent
and the code prints:

@example
compar=-1
@end example

@c page
@node utilities
@chapter Utility functions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun size_t ccsemver_id_fwrite (const ccsemver_id_t * @var{idp}, FILE * @var{stream})
Serialise the referenced identifier to the given @var{stream}.  When
successful: return the number of characters written and clear
@code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_fwrite (const ccsemver_t * @var{versionp}, FILE * @var{stream})
Serialise the referenced version to the given @var{stream}.  When
successful: return the number of characters written and clear
@code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_comp_fwrite (const ccsemver_comp_t * @var{compp}, FILE * @var{stream})
Serialise the referenced comparator to the given @var{stream}.  When
successful: return the number of characters written and clear
@code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_range_fwrite (const ccsemver_range_t * @var{rangep}, FILE * @var{stream})
Serialise the referenced range to the given @var{stream}.  When
successful: return the number of characters written and clear
@code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun const char * ccsemver_op_string (enum ccsemver_op @var{op})
Return a statically allocated @asciiz{} string representing the name of
@var{op}.  Useful for debugging purposes.
@end deftypefun

@c page
@node Package License
@appendix Unlicense


This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in
source code form or as a compiled binary, for any purpose, commercial or non--commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any
and all copyright interest in the software to the public domain. We make this dedication for the
benefit of the public at large and to the detriment of our heirs and successors. We intend this
dedication to be an overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to @url{http://unlicense.org}.

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

This package is a fork of the project Libsv by @value{ORIGIN_AUTHOR}; the original project is
available at:

@center @value{ORIGIN_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
