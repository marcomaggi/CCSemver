\input texinfo.tex
@c %**start of header
@setfilename ccsemver.info
@settitle CCSemver
@c %**end of header

@include version.texi
@include macros.texi
@include ccexceptions-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCSemver

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCSemver

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccsemver

@c To be used as @value{ORIGIN_AUTHOR} whenever we need to include the list of
@c authors of this document.
@set ORIGIN_AUTHOR              Lucas Abel

@c To be used as @value{ORIGIN_AUTHOR_URL} whenever we need to include the
@c email of the *single* author of this document.
@set ORIGIN_AUTHOR_URL          @email{https://github.com/uael}

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017, 2018, 2019

@c ------------------------------------------------------------

@set CCExceptionsVersion       0.9.0
@set CCMemoryVersion           0.2.1
@set CCStructsVersion          0.3.0
@set CCTestsVersion            0.4.1

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCSEMVER
@set PackagePkgconfigModule             ccsemver
@set PackageLibsVar                     @env{CCSEMVER_LIBS}
@set PackageCflagsVar                   @env{CCSEMVER_CFLAGS}
@c This is the stem of the library in "libccsemver.so".
@set PackageLibstem                     ccsemver
@set PackageApiPrefixLower              ccsemver_
@set PackageApiPrefixUpper              CCSEMVER_

@set PackageHeader                      ccsemver.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set OriginUrl                 @url{https://github.com/uael/sv/}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing semantic versioning for the C language.

The library supports @posix{} platforms.  The library depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: the package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

The package is distributed under the terms of the Unlicense, see @url{http://unlicense.org}.

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

This package is a fork of the project Libsv by @value{ORIGIN_AUTHOR}; the original project is
available at:

@center @value{OriginUrl}
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{ORIGIN_AUTHOR}, @value{AUTHOR}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccsemver: (ccsemver).               CCSemver, semantic versioning for C.
@end direntry
@end ifinfo

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Exceptional condition objects.
* input::                       Parser input specification.
* semvers::                     Parsing semantic versions.
* comparators::                 Parsing and using comparators.
* ranges::                      Parsing and using ranges.
* numbers::                     Parsing numbers and numeric components.
* identifiers::                 Parsing identifiers.
* utilities::                   Utility functions.

Appendices

* Package License::             Unlicense.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing semantic versioning for the C language.  A @dfn{semantic version} is described by the
@samp{v2.0.0} specification found at:

@center @url{https://semver.org/}

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: this package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the function names
in the @api{} are prefixed with @code{@value{PackageApiPrefixLower}}; all the preprocessor symbol
names are prefixed with @code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

@strong{Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccsemver_init}}.

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            Generated function names.
* overview exceptions::         Handling exceptional conditions.
* overview allocation::         Memory allocation for pathname instances.
* overview ranges::             Ranges.
* overview tags::               Prerelease tags.
* overview advanced::           Advanced range syntax.
@end menu

@include overview-linking.texi
@include overview-ccnames.texi
@include overview-ccexceptions.texi
@include overview-ccmemory.texi

@c page
@node overview ranges
@section Ranges


A @dfn{version range} is a set of @dfn{comparators} which specify versions that satisfy the range.
A comparator is composed of an @dfn{operator} and a @dfn{version}.  The set of primitive operators
is:

@table @code
@item <
Less than.

@item <=
Less than or equal to.

@item >
Greater than.

@item >=
Greater than or equal to.

@item =
Equal.  If no operator is specified, then equality is assumed, so this operator is optional, but MAY
be included.
@end table

For example, the comparator @samp{>=1.2.7} would match the versions @samp{1.2.7}, @samp{1.2.8},
@samp{2.5.3}, and @samp{1.3.9}, but not the versions @samp{1.2.6} or @samp{1.1.0}.

Comparators can be joined by whitespace to form a @dfn{comparator set},
which is satisfied by the @strong{intersection} of all of the
comparators it includes.

A range is composed of one or more comparator sets, joined by @code{||}.
A version matches a range if and only if every comparator in at least
one of the @code{||}--separated comparator sets is satisfied by the
version.

For example, the range @samp{>=1.2.7 <1.3.0} would match the versions
@samp{1.2.7}, @samp{1.2.8}, and @samp{1.2.99}, but not the versions
@samp{1.2.6}, @samp{1.3.0}, or @samp{1.1.0}.

The range @samp{1.2.7 || >=1.2.9 <2.0.0} would match the versions
@samp{1.2.7}, @samp{1.2.9}, and @samp{1.4.6}, but not the versions
@samp{1.2.8} or @samp{2.0.0}.

@c page
@node overview tags
@section Prerelease tags


If a version has a prerelease tag (for example @samp{1.2.3-alpha.3})
then it will only be allowed to satisfy comparator sets if at least one
comparator with the same @code{(major, minor, patch)} tuple also has a
prerelease tag.

For example, the range @samp{>1.2.3-alpha.3} would be allowed to match
the version @samp{1.2.3-alpha.7}, but it would @strong{not} be satisfied
by @samp{3.4.5-alpha.9}, even though @samp{3.4.5-alpha.9} is technically
``greater than'' @samp{1.2.3-alpha.3} according to the Semantic
Versioning sort rules.  The version range only accepts prerelease tags
on the @samp{1.2.3} version.  The version @samp{3.4.5} @strong{would}
satisfy the range, because it does not have a prerelease tag, and
@samp{3.4.5} is greater than @samp{1.2.3-alpha.7}.

The purpose for this behavior is twofold.

@itemize
@item
Prerelease versions frequently are updated very quickly, and contain
many breaking changes that are (by the author's design) not yet fit for
public consumption.  Therefore, by default, they are excluded from range
matching semantics.

@item
A user who has opted into using a prerelease version has clearly
indicated the intent to use @strong{that specific} set of alpha/beta/rc
versions.  By including a prerelease tag in the range, the user is
indicating that they are aware of the risk.  However, it is still not
appropriate to assume that they have opted into taking a similar risk on
the @strong{next} set of prerelease versions.
@end itemize

@c page
@node overview advanced
@section Advanced range syntax


Advanced range syntax desugars to primitive comparators in deterministic
ways.  Advanced ranges may be combined in the same way as primitive
comparators using white space or @code{||}.

@c ------------------------------------------------------------------------

@subsubheading Hyphen ranges @samp{X.Y.Z - A.B.C}


Specifies an inclusive set.

@table @asis
@item @samp{1.2.3 - 2.3.4} := @samp{>=1.2.3 <=2.3.4}
@end table

If a partial version is provided as the first version in the inclusive
range, then the missing pieces are replaced with zeroes.

@table @asis
@item @samp{1.2 - 2.3.4} := @samp{>=1.2.0 <=2.3.4}
@end table

If a partial version is provided as the second version in the inclusive
range, then all versions that start with the supplied parts of the tuple
are accepted, but nothing that would be greater than the provided tuple
parts.

@table @asis
@item @samp{1.2.3 - 2.3} := @samp{>=1.2.3 <2.4.0}

@item @samp{1.2.3 - 2} := @samp{>=1.2.3 <3.0.0}
@end table

@c ------------------------------------------------------------------------

@subsubheading X-Ranges @samp{1.2.x} @samp{1.X} @samp{1.2.*} @samp{*}


Any of @samp{X}, @samp{x}, or @samp{*} may be used to ``stand in'' for
one of the numeric values in the @code{(major, minor, patch)} tuple.

@table @asis
@item @samp{*} := @samp{>=0.0.0}
Any version satisfies.

@item @samp{1.x} := @samp{>=1.0.0 <2.0.0}
Matching major version.

@item @samp{1.2.x} := @samp{>=1.2.0 <1.3.0}
Matching major and minor versions.
@end table

A partial version range is treated as an X-Range, so the special
character is in fact optional.

@table @asis
@item Empty string := @samp{*} := @samp{>=0.0.0}

@item @samp{1} := @samp{1.x.x} := @samp{>=1.0.0 <2.0.0}

@item @samp{1.2} := @samp{1.2.x} := @samp{>=1.2.0 <1.3.0}
@end table

@c ------------------------------------------------------------------------

@subsubheading Tilde ranges @samp{~1.2.3} @samp{~1.2} @samp{~1}

Allows patch--level changes if a minor version is specified on the
comparator.  Allows minor-level changes if not.

@table @asis
@item @samp{~1.2.3} := @samp{>=1.2.3 <1.(2+1).0} := @samp{>=1.2.3 <1.3.0}

@item @samp{~1.2} := @samp{>=1.2.0 <1.(2+1).0} := @samp{>=1.2.0 <1.3.0}
Same as @samp{1.2.x}.

@item @samp{~1} := @samp{>=1.0.0 <(1+1).0.0} := @samp{>=1.0.0 <2.0.0}
Same as @samp{1.x}.

@item @samp{~0.2.3} := @samp{>=0.2.3 <0.(2+1).0} := @samp{>=0.2.3 <0.3.0}

@item @samp{~0.2} := @samp{>=0.2.0 <0.(2+1).0} := @samp{>=0.2.0 <0.3.0}
Same as @samp{0.2.x}.

@item @samp{~0} := @samp{>=0.0.0 <(0+1).0.0} := @samp{>=0.0.0 <1.0.0}
Same as @samp{0.x}.

@item @samp{~1.2.3-beta.2} := @samp{>=1.2.3-beta.2 <1.3.0}
Note that prereleases in the @samp{1.2.3} version will be allowed, if
they are greater than or equal to @samp{beta.2}.  So,
@samp{1.2.3-beta.4} would be allowed, but @samp{1.2.4-beta.2} would not,
because it is a prerelease of a different @code{(major, minor, patch)}
tuple.
@end table

@c ------------------------------------------------------------------------

@subsubheading Caret ranges @samp{^1.2.3} @samp{^0.2.5} @samp{^0.0.4}


Allow changes that do not modify the left--most non--zero digit in the
@code{(major, minor, patch)} tuple.  In other words, this allows patch
and minor updates for versions @samp{1.0.0} and above, patch updates for
versions @samp{0.X >=0.1.0}, and @strong{no} updates for versions
@samp{0.0.X}.

Many authors treat a @samp{0.x} version as if the @samp{x} were the
major ``breaking change'' indicator.

Caret ranges are ideal when an author may make breaking changes between
@samp{0.2.4} and @samp{0.3.0} releases, which is a common practice.
However, it presumes that there will @strong{not} be breaking changes
between @samp{0.2.4} and @samp{0.2.5}.  It allows for changes that are
presumed to be additive (but non--breaking), according to commonly
observed practices.

@table @asis
@item @samp{^1.2.3} := @samp{>=1.2.3 <2.0.0}

@item @samp{^0.2.3} := @samp{>=0.2.3 <0.3.0}

@item @samp{^0.0.3} := @samp{>=0.0.3 <0.0.4}

@item @samp{^1.2.3-beta.2} := @samp{>=1.2.3-beta.2 <2.0.0}
Note that prereleases in the @samp{1.2.3} version will be allowed, if
they are greater than or equal to @samp{beta.2}.  So,
@samp{1.2.3-beta.4} would be allowed, but @samp{1.2.4-beta.2} would not,
because it is a prerelease of a different @code{(major, minor, patch)}
tuple.

@item @samp{^0.0.3-beta} := @samp{>=0.0.3-beta <0.0.4}
Note that prereleases in the @samp{0.0.3} version @strong{only} will be
allowed, if they are greater than or equal to @samp{beta}.  So,
@samp{0.0.3-pr.2} would be allowed.
@end table

When parsing caret ranges, a missing @code{patch} value desugars to the
number @samp{0}, but will allow flexibility within that value, even if
the major and minor versions are both @samp{0}.

@table @asis
@item @samp{^1.2.x} := @samp{>=1.2.0 <2.0.0}

@item @samp{^0.0.x} := @samp{>=0.0.0 <0.1.0}

@item @samp{^0.0} := @samp{>=0.0.0 <0.1.0}
@end table

A missing @code{minor} and @code{patch} values will desugar to zero, but
also allow flexibility within those values, even if the major version is
zero.

@table @asis
@item @samp{^1.x} := @samp{>=1.0.0 <2.0.0}

@item @samp{^0.x} := @samp{>=0.0.0 <1.0.0}
@end table

@c page
@node init
@chapter Library initialisation


@deftypefun void ccsemver_library_init (void)
Initialises the internal structures of the library.  It is fine to call this function multiple
times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccsemver_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccsemver_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccsemver_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccsemver_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@menu
* conditions parser error::     Parser error.
* conditions parser input::     Parser input errors.
* conditions parser invalid::   Invalid input to parser.
@end menu

@c page
@node conditions parser error
@section Parser error


The @dfn{parser error exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting to parse an invalid input string.

There should be only one @emph{parser error} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_error_t
Structure type representing the descriptor for @emph{parser error} condition objects.  This
descriptor has @objtype{cce_descriptor_runtime_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_error_t
Structure type representing an @emph{parser error} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_error (ccsemver_condition_parser_error_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_error_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_error (void)
Return a pointer to the statically allocated structure representing the single @emph{parser error}
condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_error (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{parser error} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions parser input
@section Parser input errors


@menu
* conditions parser input no input::  No input available while parsing.
* conditions parser input empty::     Input is empty while parsing.
* conditions parser input eoi::       Unexpected end-of-input while parsing.
* conditions parser input offset::    Invalid input offset while parsing.
@end menu

@c page
@node conditions parser input no input
@subsection No input available while parsing


The @dfn{no input exceptional--condition object} has the purpose of describing an exceptional
condition caused by finding no available input while parsing semantic version strings.

There should be only one @emph{no input} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_no_input_t
Structure type representing the descriptor for @emph{no input} condition objects.  This descriptor
has @objtype{ccsemver_descriptor_parser_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_no_input_t
Structure type representing an @emph{no input} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_no_input (ccsemver_condition_parser_no_input_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_no_input_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_no_input (void)
Return a pointer to the statically allocated structure representing the single @emph{no input}
condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_no_input (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{no input} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions parser input empty
@subsection empty input while parsing


The @dfn{empty input exceptional--condition object} has the purpose of describing an exceptional
condition caused by empty input while parsing semantic version strings.

There should be only one @emph{empty input} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_empty_input_t
Structure type representing the descriptor for @emph{empty input} condition objects.  This
descriptor has @objtype{ccsemver_descriptor_parser_no_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_empty_input_t
Structure type representing an @emph{empty input} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_empty_input (ccsemver_condition_parser_empty_input_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_empty_input_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_empty_input (void)
Return a pointer to the statically allocated structure representing the single @emph{empty input}
condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_empty_input (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{empty input} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions parser input eoi
@subsection Unexpected end--of--input while parsing


The @dfn{unexpected end--of--input exceptional--condition object} has the purpose of describing an
exceptional condition caused by an unexpected end--of--input while parsing semantic version strings.

There should be only one @emph{unexpected end--of--input} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_end_of_input_t
Structure type representing the descriptor for @emph{unexpected end--of--input} condition objects.
This descriptor has @objtype{ccsemver_descriptor_parser_no_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_end_of_input_t
Structure type representing an @emph{unexpected end--of--input} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_end_of_input (ccsemver_condition_parser_end_of_input_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_end_of_input_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_end_of_input (void)
Return a pointer to the statically allocated structure representing the single @emph{unexpected
end--of--input} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_end_of_input (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{unexpected end--of--input} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions parser input offset
@subsection Invalid input offset while parsing


The @dfn{invalid input offset exceptional--condition object} has the purpose of describing an
exceptional condition caused by attempting to access the input string at an invalid offset, while
parsing semantic version strings.

There should be only one @emph{invalid input offset} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_invalid_input_offset_t
Structure type representing the descriptor for @emph{invalid input offset} condition objects.  This
descriptor has @objtype{ccsemver_descriptor_parser_no_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_invalid_input_offset_t
Structure type representing an @emph{invalid input offset} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_invalid_input_offset (ccsemver_condition_parser_invalid_input_offset_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_invalid_input_offset_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_invalid_input_offset (void)
Return a pointer to the statically allocated structure representing the single @emph{invalid input
offset} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_invalid_input_offset (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{invalid input offset} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions parser invalid
@section Invalid input to parser


@menu
* conditions parser invalid number::   Expected number.
* conditions parser invalid numcomp::  Expected numeric component.
* conditions parser invalid xnumcomp:: Expected X-Range numeric component.
* conditions parser invalid id::       Expected identifier.
* conditions parser invalid numrange:: Number out of range.
@end menu

@c page
@node conditions parser invalid number
@subsection Expected number


The @dfn{expected number exceptional--condition object} has the purpose of describing an exceptional
condition caused by invalid input when a number was expected, while parsing semantic version
strings.

There should be only one @emph{expected number} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_expected_number_t
Structure type representing the descriptor for @emph{expected number} condition objects.  This
descriptor has @objtype{ccsemver_descriptor_parser_invalid_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_expected_number_t
Structure type representing an @emph{expected number} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_expected_number (ccsemver_condition_parser_expected_number_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_expected_number_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_expected_number (void)
Return a pointer to the statically allocated structure representing the single @emph{expected
number} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_expected_number (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{expected number} condition object; otherwise return
@cfalse{}.
@end deftypefun


@c page
@node conditions parser invalid numcomp
@subsection Expected numeric component


The @dfn{expected numeric component exceptional--condition object} has the purpose of describing an
exceptional condition caused by invalid input when a numeric component was expected, while parsing
semantic version strings.

There should be only one @emph{expected numeric component} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_expected_numeric_component_t
Structure type representing the descriptor for @emph{expected numeric component} condition objects.
This descriptor has @objtype{ccsemver_descriptor_parser_invalid_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_expected_numeric_component_t
Structure type representing an @emph{expected numeric component} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_expected_numeric_component (ccsemver_condition_parser_expected_numeric_component_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_expected_numeric_component_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_expected_numeric_component (void)
Return a pointer to the statically allocated structure representing the single @emph{expected
numeric component} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_expected_numeric_component (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{expected numeric component} condition object; otherwise
return @cfalse{}.
@end deftypefun

@c page
@node conditions parser invalid xnumcomp
@subsection Expected X-Range numeric component


The @dfn{expected X-Range numeric component exceptional--condition object} has the purpose of
describing an exceptional condition caused by invalid input when a X-Range numeric component was
expected, while parsing semantic version strings.  This exception is raised, for example, when
parsing a range and a numeric component is present after a X-Range one; for example @samp{X.X.X} is
a valid range, while @samp{X.2} and @samp{X.X.3} are invalid because @samp{2} and @samp{3} would be
ignored.

There should be only one @emph{expected X-Range numeric component} condition object: the one
predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_expected_xrange_numeric_component_t
Structure type representing the descriptor for @emph{expected X-Range numeric component} condition
objects.  This descriptor has @objtype{ccsemver_descriptor_parser_invalid_input_t} as parent
descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_expected_xrange_numeric_component_t
Structure type representing an @emph{expected X-Range numeric component} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_expected_xrange_numeric_component (ccsemver_condition_parser_expected_xrange_numeric_component_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_expected_xrange_numeric_component_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_expected_xrange_numeric_component (void)
Return a pointer to the statically allocated structure representing the single @emph{expected
X-Range numeric component} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_expected_xrange_numeric_component (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{expected X-Range numeric component} condition object;
otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions parser invalid id
@subsection Expected identifier


The @dfn{expected identifier exceptional--condition object} has the purpose of describing an
exceptional condition caused by invalid input when a identifier was expected, while parsing semantic
version strings.

There should be only one @emph{expected identifier} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_expected_identifier_t
Structure type representing the descriptor for @emph{expected identifier} condition objects.  This
descriptor has @objtype{ccsemver_descriptor_parser_invalid_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_expected_identifier_t
Structure type representing an @emph{expected identifier} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_expected_identifier (ccsemver_condition_parser_expected_identifier_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_expected_identifier_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_expected_identifier (void)
Return a pointer to the statically allocated structure representing the single @emph{expected
identifier} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_expected_identifier (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{expected identifier} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions parser invalid numrange
@subsection Number out of range


The @dfn{number out of range exceptional--condition object} has the purpose of describing an
exceptional condition caused by a attempting to parse a number and finding it out of its allowed
range, while parsing semantic version strings.

There should be only one @emph{number out of range} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_descriptor_parser_number_out_of_range_t
Structure type representing the descriptor for @emph{number out of range} condition objects.  This
descriptor has @objtype{ccsemver_descriptor_parser_invalid_input_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccsemver_condition_parser_number_out_of_range_t
Structure type representing an @emph{number out of range} condition object.
@end deftp


@deftypefun void ccsemver_condition_init_parser_number_out_of_range (ccsemver_condition_parser_number_out_of_range_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccsemver_condition_parser_number_out_of_range_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccsemver_condition_new_parser_number_out_of_range (void)
Return a pointer to the statically allocated structure representing the single @emph{number out of
range} condition object.
@end deftypefun


@deftypefun bool ccsemver_condition_is_parser_number_out_of_range (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{number out of range} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node input
@chapter Parser input specification


Every parser functions accepts as argument a pointer to @objtype{ccsemver_input_t} to keep track of
which input characters have been consumed.  The whole parser input strings are meant to be loaded in
memory.  Usage example:

@example
char const * const str    = "1.2.3-alpha.1+x86-64";
size_t const       len    = strlen(str);
size_t const       offset = 0;
ccsemver_input_t   input  = ccsemver_input_new(str, len, offset);
@end example


@deftp {Struct Typedef} ccsemver_input_t
Type of @code{struct} representing the input for the parser functions; the input is meant to be a
string in @ascii{} format.  It has the following public fields:

@table @code
@item char const * const str
Pointer to the first character in the input string.  Parser functions never mutate this value.

@item size_t const len
Number of characters in the input string.  Parser functions never mutate this value.

@item size_t off
Offset of the next character to parse in the input string.  This value is mutated by every parser
function.
@end table

For every parser function: the input string is referenced by @code{str}; the length of the input
string is @code{len} characters; the field @code{off} is both an input and output parameter:

@itemize
@item
Upon entering the function: @code{off} is the offset of the first character to parse in @code{str}.

@item
When the function returns successfully: @code{off} is the offset of the first non--parsed character;
further parsing operations can use such value as input.

@item
When the function returns unsuccessfully: @code{off} is invalid.
@end itemize

Unless otherwise specified, for every parser function: if the input string is empty (@code{len} is
zero), the function returns unsuccessfully.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Constructors


@deftypefun ccsemver_input_t ccsemver_input_new (char const * @var{str}, size_t @var{len}, size_t @var{off})
Build and return a new instance of @objtype{ccsemver_input_t}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Predicates


@deftypefun bool ccsemver_input_is_empty (ccsemver_input_t * @var{input})
Return @ctrue{} if the input string has zero length; otherwise return @cfalse{}.  Notice that ``zero
length'' is different from ``no more input''.
@end deftypefun


@deftypefun bool ccsemver_input_more (ccsemver_input_t * @var{input})
Return @ctrue{} if there is more input to be parsed; return @cfalse{} if all the input has been
processed.
@end deftypefun


@deftypefun bool ccsemver_input_at_end (ccsemver_input_t * @var{input})
Return @ctrue{} if there is @strong{no} more input to be parsed; return @cfalse{} if there is more
input to be processed.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Operations


@deftypefun char ccsemver_input_next (ccsemver_input_t * @var{input})
Return the next character to parse.  Do @strong{not} mutate the field @code{off}.
@end deftypefun


@deftypefun void ccsemver_input_step (ccsemver_input_t * @var{input})
Increment the field @code{off}.
@end deftypefun

@c page
@node semvers
@chapter Parsing semantic versions


@menu
* semvers intro::               Introduction to semantic versions.
* semvers typedefs::            Type definitions.
* semvers reading::             Parsing from a string.
* semvers writing::             Writing to a string.
* semvers comparing::           Versions comparison.
@end menu

@c page
@node semvers intro
@section Introduction to semantic versions


For the full specification version @samp{v2.0.0} we should refer to:

@center @url{https://semver.org/}

@dfn{Semantic versions} are strings in @ascii{} encoding with the following format:

@example
1.2.3-alpha.1-beta.2+x86-64
@end example

@noindent
where:

@table @samp
@item 1
Is the major version number; it is mandatory.

@item 2
Is the minor version number; it is mandatory.

@item 3
Is the patch level; it is mandatory.

@item -alpha.1-beta.2
Is the prerelease tag; it is optional.  The leading dash character is the separator: if a dash is
present after the patch level, there must be a prerelease tag.  Prerelease tags cannot be empty.

@item +x86-64
Is the build metadata; it is optional.  The leading plus character is the separator: if a plus is
present after the patch level or the prerelease tag, there must be a build metadata.  The build
metadata cannot be empty.
@end table

Other examples of valid semantic versions:

@example
1.2.3
1.2.3-alpha.1-beta.2
1.2.3+x86-64
@end example

@c page
@node semvers typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_sv_t
Type of data structures representing parsed versions.  Instances of this structure are initialised
with @cfunc{ccsemver_ctor}.  Instances of this structure are finalised with @cfunc{ccsemver_dtor}.

The semantic versions @api{} does @strong{not} duplicate the input strings.

It has the following public fields:

@table @code
@item long major
An integer representing the major version number.

@item long minor
An integer representing the minor version number.

@item long patch
An integer representing the patch level.

@item ccsemver_id_t prerelease
An identifier representing the prerelease tag.

@item ccsemver_id_t build
An identifier representing the build metadata.

@item size_t len
The number of characters in the input string that where parsed to form this version.

@item char const * raw
Pointer to the character in the input string representing the first character of this component.
This pointer is valid as long as the input string handed to the constructor function is not mutated.
@end table
@end deftp


@deftypefun void ccsemver_ctor (ccsemver_sv_t * @var{sv})
Initialise to empty an already allocated data structure representing a parsed version.  Every call
to this function must be matched by a call to @cfunc{ccsemver_dtor}:

@example
ccsemver_sv_t        sv;

ccsemver_ctor(&sv);
@{
  /* Do something with "sv" here. */
@}
ccsemver_dtor(&sv);
@end example
@end deftypefun


@deftypefun void ccsemver_dtor (ccsemver_sv_t * @var{sv})
Finalise to empty a data structure representing a parsed version; calls to this function must match
a previous call to @cfunc{ccsemver_ctor} or @cfunc{ccsemver_read}.

All the resources associated to @var{sv} are released, but the structure itself.  The following code
is correct:

@example
ccsemver_sv_t        sv;

ccsemver_ctor(&sv);
@{
  /* Do something with "sv" here. */
@}
ccsemver_dtor(&sv);
@end example

@noindent
the following code is also correct:

@example
ccsemver_sv_t *      svp;

svp = malloc(sizeof(ccsemver_sv_t));
assert(NULL != svp);
@{
  ccsemver_ctor(svp);
  @{
    /* Do something with "svp" here. */
  @}
  ccsemver_dtor(svp);
@}
free(svp);
@end example
@end deftypefun

@c page
@node semvers reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_read (ccsemver_sv_t * @var{sv}, ccsemver_input_t * @var{input})
Parse input expecting a semantic version specification.  When successful: the return value is
@code{0}.  If an error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{sv}; the
structure is first initialised with @cfunc{ccsemver_ctor}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_dtor} to @var{sv}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a numeric version

The following example parses the numeric version @samp{1.2.3}:

@example
char const            input_str[] = "1.2.3";
ccsemver_input_t      input =
  ccsemver_input_new(input_str, strlen(input_str), 0);
ccsemver_sv_t            sv;
char                  rv;

rv = ccsemver_read(&sv, &input);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         sv.major, sv.minor, sv.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&sv.prerelease, stdout);
  printf(", build=");
  ccsemver_id_fwrite(&sv.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&sv);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=, build=
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a tagged version

The following example parses the version @samp{1.2.3-alpha.7}, which has
a prerelease tag:

@example
char const    input_str[] = "1.2.3-alpha.7";
ccsemver_input_t      input =
  ccsemver_input_new(input_str, strlen(input_str), 0);
ccsemver_sv_t            sv;
char                  rv;

rv = ccsemver_read(&sv, &input);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         sv.major, sv.minor, sv.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&sv.prerelease, stdout);
  printf(", build=");
  ccsemver_id_fwrite(&sv.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&sv);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=alpha.7, build=
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a full version

The following example parses the version @samp{1.2.3-alpha.7+x86-64},
which has both a prerelease tag and build metadata:

@example
char const    input_str[] = "1.2.3-alpha.7+x86-64";
ccsemver_sv_t      version;
size_t        input_off = 0;
char          rv;

rv = ccsemver_read(&version, input_str, strlen(input_str), &input_off);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         version.major, version.minor, version.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&version.prerelease, stdout);
  printf(", ");
  printf("build=");
  ccsemver_id_fwrite(&version.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&version);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=alpha.7, build=x86-64
@end example

@c page
@node semvers writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_write (ccsemver_sv_t const * @var{sv}, char * @var{output_buf}, size_t @var{output_len})
Serialise the version @var{sv} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full version serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a version

The following example serialises a version specification:

@example
static const char     input_str[] = "1.2.3-alpha.7";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_sv_t      version;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_read(&version, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_write(&version, \
     buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
        needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, id=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
len=13, actual_count=13, id=1.2.3-alpha.7
@end example

@c page
@node semvers comparing
@section Versions comparison


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_comp (ccsemver_sv_t const * @var{A}, ccsemver_sv_t const * @var{B})
Compare the given versions.  Return @code{-1} if @var{A} is less than @var{B}; return @code{0} if
@var{A} is equal to @var{B}; return @code{+1} if @var{A} is greater than @var{B}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: comparing versions


The following example compares two versions:

@example
static const char     input_str_A[] = "1.2.3";
static const char     input_str_B[] = "1.2.4";
ccsemver_sv_t      version_A, version_B;
size_t        offset_A = 0, offset_B = 0;
char          rv;

rv = ccsemver_read(&version_A, input_str_A,
                   strlen(input_str_A), &offset_A);
if (0 == rv) @{
  rv = ccsemver_read(&version_B, input_str_B,
                   strlen(input_str_B), &offset_B);
  if (0 == rv) @{
    char    compar = ccsemver_comp(&version_A, &version_B);
    printf("compar=%d\n", (int)compar);
  @}
  ccsemver_dtor(&version_B);
@}
ccsemver_dtor(&version_A);
@end example

@noindent
and the code prints:

@example
compar=-1
@end example

@c page
@node comparators
@chapter Parsing and using comparators


The comparators @api{} does @strong{not} duplicate the input strings.

@menu
* comparators constants::       Constants definitions.
* comparators typedefs::        Type definitions.
* comparators reading::         Parsing from a string.
* comparators writing::         Writing to a string.
* comparators matching::        Matching with versions.
@end menu

@c page
@node comparators constants
@section Constants definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp Enumeration ccsemver_op_t
Type of enumeration representing the comparison criteria for comparators.
@end deftp


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_EQ
Represent the ``equality'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_LT
Represent the ``less than'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_LE
Represent the ``less than or equal to'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_GT
Represent the ``greater than'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_GE
Represent the ``greater than or equal to'' operator.
@end deftypevr

@c page
@node comparators typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_comp_t
Type of @code{struct} representing parsed comparators.  Every instance of this structure is a node
in a simply--linked list.  Instances of this structure are initialised with
@cfunc{ccsemver_comp_ctor} or @cfunc{ccsemver_comp_read}.  Instances of this structure are finalised
with @cfunc{ccsemver_comp_dtor}.

It has the following public fields:

@table @code
@item ccsemver_comp_t * next
Pointer to the next comparator in the linked list; @cnull{} if this instance is the last in the
list.

@item ccsemver_op_t op
The operator specification for this comparator.

@item ccsemver_sv_t version
The version specification for this comparator.
@end table
@end deftp


@deftypefun void ccsemver_comp_ctor (ccsemver_comp_t * @var{cmp})
Initialise to empty an already allocated data structure representing a parsed comparator.  Every
call to this function must be matched by a call to @cfunc{ccsemver_comp_dtor}:

@example
ccsemver_comp_t   comp;

ccsemver_comp_ctor(&comp);
@{
  /* Do something with "comp" here. */
@}
ccsemver_comp_dtor(&comp);
@end example
@end deftypefun


@deftypefun void ccsemver_comp_dtor (ccsemver_comp_t * @var{cmp})
Finalise to empty a data structure representing a parsed comparator; calls to this function must
match a previous call to @cfunc{ccsemver_comp_ctor} or @cfunc{ccsemver_comp_read}.

All the resources associated to @var{cmp} are released, but the structure itself.  The following
code is correct:

@example
ccsemver_comp_t   comp;

ccsemver_comp_ctor(&comp);
@{
  /* Do something with "comp" here. */
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
the following code is also correct:

@example
ccsemver_comp_t * cmp;

cmp = malloc(sizeof(ccsemver_comp_t));
assert(NULL != cmp);
@{
  ccsemver_comp_ctor(cmp);
  @{
    /* Do something with "cmp" here. */
  @}
  ccsemver_comp_dtor(cmp);
@}
free(cmp);
@end example
@end deftypefun

@c page
@node comparators reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_comp_read (ccsemver_comp_t * @var{cmp}, ccsemver_input_t * @var{input})
Parse input expecting a comparator specification.  When successful: the return value is @code{0}.
If an error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{cmp}; the
structure is first initialised with @cfunc{ccsemver_comp_ctor}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_comp_dtor} to @var{cmp}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun char ccsemver_comp_and (ccsemver_comp_t * @var{cmp}, ccsemver_input_t * @var{input})
Parse input expecting a comparator specification.  When successful: the return value is @code{0}.
If an error occurs: the return value is @code{1}.

The results of parsing are appended to the already allocated and built structure referenced by
@var{cmp}.

In the unsuccessful case: the structure referenced by @var{cmp} is left untouched.

If the input is empty: the comparator is initialised as if the input is @samp{>=0.0.0}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a comparator

The following example parses the comparator specification
@samp{<=1.2.3}:

@example
static const char     input_str[] = "<=1.2.3";
ccsemver_comp_t comp;
size_t        offset = 0;
char          rv;

rv = ccsemver_comp_read(&comp, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("operation=%s, ", ccsemver_op_string(comp.op));
  ccsemver_fwrite(&comp.version, stdout);
  printf("\n");
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
and it prints:

@example
operation=CCSEMVER_OP_LE, 1.2.3
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: extending a comparator

The following example parses the comparator specification
@samp{<=1.2.3} and then extends it with @samp{<3.0.0}:

@example
static const char     input_str_1[] = ">=1.2.3";
static const char     input_str_2[] = "<3.0.0";
ccsemver_comp_t comp;
size_t        offset_1 = 0;
size_t        offset_2 = 0;
char          rv;

rv = ccsemver_comp_read(&comp, \
        input_str_1, strlen(input_str_1), &offset_1);
if (0 == rv) @{
  rv = ccsemver_comp_and(&comp, \
          input_str_2, strlen(input_str_2), &offset_2);
  if (0 == rv) @{
    for (ccsemver_comp_t * it = &comp; it; it = it->next) @{
      printf("operation=%s, ", ccsemver_op_string(it->op));
      ccsemver_fwrite(&(it->version), stdout);
      printf("\n");
    @}
    printf("comparator: ");
    ccsemver_comp_fwrite(&comp, stdout);
    printf("\n");
  @}
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
and it prints:

@example
operation=CCSEMVER_OP_GE, 1.2.3
operation=CCSEMVER_OP_LT, 3.0.0
comparator: >=1.2.3 <3.0.0
@end example

@c page
@node comparators writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_comp_write (ccsemver_comp_t const * @var{cmp}, char * @var{output_buf}, size_t @var{output_len})
Serialise the comparator @var{cmp} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full comparator serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a comparator


The following example serialises a comparator:

@example
static const char     input_str[] = "<=1.2.3";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_comp_t comp;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_comp_read(&comp, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_comp_write(&comp, \
                    buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
                       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, comp=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
the code prints:

@example
len=7, actual_count=7, comp=<=1.2.3
@end example

@c page
@node comparators matching
@section Matching with versions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_match (ccsemver_sv_t const * @var{sv}, ccsemver_comp_t const * @var{cmp})
Match a version referenced by @var{sv} against all the comparators in the linked list referenced by
@var{cmp}.  The return value is @code{1} if the version matches; it is @code{0} otherwise.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: matching a version


The following example matches a version against a standalone comparator:

@example
const char      version_str[] = "1.2.3";
const char      compar_str[]  = ">=2.0.0";
ccsemver_sv_t      version;
ccsemver_comp_t comp;
size_t          version_off = 0, comp_off = 0;
char            rv;

rv = ccsemver_read(&version, \
        version_str, strlen(version_str), &version_off);
if (0 == rv) @{
  rv = ccsemver_comp_read(&comp, \
          compar_str, strlen(compar_str), &comp_off);
  if (0 == rv) @{
    int       result = (int)ccsemver_match(&version, &comp);
    printf("matches?=%s\n", (result)? "yes" : "no");
  @}
  ccsemver_comp_dtor(&comp);
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
matches?=no
@end example

@c page
@node ranges
@chapter Parsing and using ranges


The ranges @api{} does @strong{not} duplicate the input strings.

@menu
* ranges typedefs::             Type definitions.
* ranges reading::              Parsing from a string.
* ranges writing::              Writing to a string.
* ranges matching::             Matching ranges and versions.
@end menu

@c page
@node ranges typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_range_t
Type of @code{struct} representing parsed ranges; a range is a set of comparators.  Every instance
of this structure is a node in a simply--linked list.  Instances of this structure are initialised
with @cfunc{ccsemver_range_read}.  Instances of this structure are finalised with
@cfunc{ccsemver_range_dtor}.

It has the following public fields:

@table @code
@item ccsemver_range_t * next
Pointer to the next structure in the linked list; @cnull{} if this instance is the last in the list.

@item ccsemver_comp_t comp
A version comparator.
@end table
@end deftp


@deftypefun void ccsemver_range_dtor (ccsemver_range_t * @var{rn})
Finalise to empty a data structure representing a parsed range; calls to this function must match a
previous call to @cfunc{ccsemver_range_read}.

All the resources associated to @var{rn} are released, but the structure itself.  The following code
is correct:

@example
ccsemver_range_t  range;

ccsemver_range_read(&range, ...);
@{
  /* Do something with "range" here. */
@}
ccsemver_range_dtor(&range);
@end example

@noindent
the following code is also correct:

@example
ccsemver_range_t * rn;

rn = malloc(sizeof(ccsemver_range_t));
assert(NULL != rn);
@{
  ccsemver_range_read(&range, ...);
  @{
    /* Do something with "rn" here. */
  @}
  ccsemver_range_dtor(rn);
@}
free(rn);
@end example
@end deftypefun

@c page
@node ranges reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_range_read (ccsemver_range_t * @var{rn}, ccsemver_input_t * @var{input})
Parse input expecting a range specification.  When successful: the return value is @code{0}.  If an
error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{rn}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_range_dtor} to @var{rn}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a range

The following example parses the range specification @samp{1.2.7 || >=1.2.9 <2.0.0}:

@example
static const char  input_str[] = "1.2.7 || >=1.2.9 <2.0.0";
ccsemver_range_t     range;
size_t             offset = 0;
char               rv;

rv = ccsemver_range_read(&range, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("range: ");
  ccsemver_range_fwrite(&range, stdout);
  printf("\n");
@}
ccsemver_range_dtor(&range);
@end example

@noindent
and it prints:

@example
range: 1.2.7 || >=1.2.9 <2.0.0
@end example

@c page
@node ranges writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_range_write (ccsemver_range_t const * @var{rn}, char * @var{output_buf}, size_t @var{output_len})
Serialise the range @var{rn} as @ascii{} string in the memory block referenced by @var{output_buf},
which has at least @var{output_len} characters available.  If the buffer has not enough room to hold
the full comparator serialisation: the string is truncated to @var{output_len} characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a range


The following example serialises a range:

@example
static const char     input_str[] = \
   "1.2.7 || >=1.2.9 <2.0.0";
size_t                buffer_len = 32;
char                  buffer_ptr[buffer_len];
ccsemver_range_t        range;
size_t                offset = 0;
char                  rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_range_read(&range, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_range_write(&range, \
     buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, range=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_range_dtor(&range);
@end example

@noindent
the code prints:

@example
len=23, actual_count=23, range=1.2.7 || >=1.2.9 <2.0.0
@end example

@c page
@node ranges matching
@section Matching ranges and versions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_range_match (ccsemver_sv_t const * @var{sv}, ccsemver_range_t const * @var{rangep})
Match a version referenced by @var{sv} against the comparators in the range referenced by
@var{rangep}.  The return value is @code{1} if the version matches at least one comparator; it is
@code{0} otherwise.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: matching a version


The following example matches a version against a range:

@example
static const char     version_str[] = "1.4.6";
static const char     range_str[]  = "1.2.7 || >=1.2.9 <2.0.0";
ccsemver_sv_t              version;
ccsemver_range_t        range;
size_t                version_off = 0, range_off = 0;
char                  rv;

rv = ccsemver_read(&version, \
        version_str, strlen(version_str), &version_off);
if (0 == rv) @{
  rv = ccsemver_range_read(&range, \
          range_str, strlen(range_str), &range_off);
  if (0 == rv) @{
    int       result = (int)ccsemver_range_match(&version, &range);
    printf("matches?=%s\n", (result)? "yes" : "no");
  @}
  ccsemver_range_dtor(&range);
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
matches?=yes
@end example

@c page
@node numbers
@chapter Parsing numbers and numeric components


In the context of @value{PACKAGE}'s parsing functions, @dfn{numeric components} are @ascii{} strings
holding: numeric characters (according to the standard function @cfunc{isdigit}); the standalone
character @samp{x}; the standalone character @samp{X}; the standalone character @samp{*}.

Usually we do @strong{not} need to use the numeric components parser directly.

All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_parse_number (long * @var{nump}, ccsemver_input_t * @var{input})
Parse input expecting plain number.  When successful: the return value is @code{0}.  If an error
occurs: the return value is @code{1}.

The results of parsing are stored in the variable referenced by @var{nump}.

The following example code parses a numeric component:

@example
char const *    input_str = "123";
size_t          input_len = strlen(input_str);
long            num;
size_t          input_off = 0;
char            rv;

rv = ccsemver_parse_number(&num, input_str, input_len, &input_off);
if (0 == rv) @{
  printf("num=%ld\n", num);
@}
@end example
@end deftypefun


@deftypefun char ccsemver_num_parse (long * @var{nump}, ccsemver_input_t * @var{input})
Parse input expecting a numeric component.  When successful: the return value is @code{0}.  If an
error occurs: the return value is @code{1}.

The results of parsing are stored in the variable referenced by @var{nump}.

If the input string contains @samp{x}, @samp{X} or @samp{*}: the function returns successfully and
stores the value @code{CCSEMVER_NUM_X} in the variable referenced by @var{nump}.

The following example code parses a numeric component:

@example
char const *    input_str = "123";
size_t          input_len = strlen(input_str);
long            num;
size_t          input_off = 0;
char            rv;

rv = ccsemver_num_parse(&num, input_str, input_len, &input_off);
if (0 == rv) @{
  printf("num=%ld\n", num);
@}
@end example
@end deftypefun


@deftypevr {Preprocessor Symbol} long CCSEMVER_NUM_X
Special value used to represent a numeric component specified as @samp{x}, @samp{X} or @samp{*}.
@end deftypevr


@deftypefun int ccsemver_num_comp (long @var{A}, long @var{B})
Compare the given integers.  Return @code{-1} if @var{A} is less than @var{B}; return @code{0} if
@var{A} is equal to @var{B}; return @code{+1} if @var{A} is greater than @var{B}.

The return values of this function are @strong{invalid} if one of the arguments is
@code{CCSEMVER_NUM_X}.
@end deftypefun

@c page
@node identifiers
@chapter Parsing identifiers


In the context of @value{PACKAGE}'s parsing functions, identifiers are @ascii{} strings holding:
alphanumeric characters (according to the standard function @cfunc{isalnum}); dash characters; dot
characters.  Dot characters are interpreted as separators between components; a plus character is
interpreted as ending character for an identifier.

The semantic version string:

@example
1.2.3-alpha.7+x86-64
@end example

@noindent
contains as ``prerelease tag'' the identifier:

@example
alpha.7
@end example

@noindent
which is represented as a linked list of two instances of @objtype{ccsemver_id_t}; the first
instance references the identifier component @samp{alpha}; the second instance references the
identifier component @samp{7}.

Usually we do @strong{not} need to use the identifiers parser directly.

@menu
* identifiers typedefs::        Type definitions.
* identifiers reading::         Parsing from a string.
* identifiers writing::         Writing to a string.
* identifiers comparing::       Identifiers comparison.
@end menu

@c page
@node identifiers typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_id_t
Type of @code{struct} representing a single component in a parsed identifier; every instance of this
structure is a node in a simply--linked list.  The identifiers @api{} does @strong{not} duplicate
the input strings.  Instances of this structure are initialised with @cfunc{ccsemver_id_ctor} or
@cfunc{ccsemver_id_read}.  Instances of this structure are finalised with @cfunc{ccsemver_id_dtor}.

The structure has the following public fields:

@table @code
@item bool numeric
A boolean value: @ctrue{} if the this component is numeric; @cfalse{} if this component is
alphabetic.

@item long num
If this component is numeric: this field holds its numeric representation.  Otherwise this field
holds a meaningless value.

@item size_t len
The number of characters in the input string that where parsed to form this component.

@item const char * raw
Pointer to the character in the input string representing the first character of this component.
This pointer is valid as long as the input string handed to @cfunc{ccsemver_id_read} is not mutated.

@item ccsemver_id_t * next
Pointer to the next node in the linked list; @cnull{} if this structure is the last node.
@end table
@end deftp


@deftypefun void ccsemver_id_ctor (ccsemver_id_t * @var{id})
Initialise to empty an already allocated data structure representing a parsed identifier.  Every
call to this function must be matched by a call to @cfunc{ccsemver_id_dtor}:

@example
ccsemver_id_t     id;

ccsemver_id_ctor(&id);
@{
  /* Do something with "id" here. */
@}
ccsemver_id_dtor(&id);
@end example
@end deftypefun


@deftypefun void ccsemver_id_dtor(ccsemver_id_t * @var{id})
Finalise to empty a data structure representing a parsed identifier; calls to this function must
match a previous call to @cfunc{ccsemver_id_ctor} or @cfunc{ccsemver_id_read}.

All the resources associated to @var{id} are released, but the structure itself.  The following
code is correct:

@example
ccsemver_id_t     id;

ccsemver_id_ctor(&id);
@{
  /* Do something with "id" here. */
@}
ccsemver_id_dtor(&id);
@end example

@noindent
the following code is also correct:

@example
ccsemver_id_t *   id;

id = malloc(sizeof(ccsemver_id_t));
assert(NULL != id);
@{
  ccsemver_id_ctor(id);
  @{
    /* Do something with "id" here. */
  @}
  ccsemver_id_dtor(id);
@}
free(id);
@end example
@end deftypefun

@c page
@node identifiers reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_id_read (ccsemver_id_t * @var{id}, ccsemver_input_t * @var{input})
Parse input expecting an identifier.  When successful: the return value is @code{0}.  If an error
occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{id}; the
structure is first initialised with @cfunc{ccsemver_id_ctor}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_id_dtor} to @var{id}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a numeric identifier

The following example parses the numeric identifier @samp{123}:

@example
static const char     input_str[] = "123";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("numeric?=%d, num=%ld, len=%lu, raw=%s, next=%p\n",
         (int)id.numeric, id.num, id.len, id.raw,
         (void *)id.next);
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=1, num=123, len=3, raw=123, next=(nil)
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing an alphabetic identifier

The following example parses the alphabetic identifier @samp{alpha}:

@example
static const char     input_str[] = "alpha";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("numeric?=%d, num=%ld, len=%lu, raw=%s, next=%p\n",
         (int)id.numeric, id.num, id.len, id.raw,
         (void *)id.next);
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha, next=(nil)
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a compound identifier


The following example parses the compound identifier @samp{1.2.3-alpha.7}:

@example
const char     input_str[] = "1.2.3-alpha.7";
ccsemver_id_t  id;
size_t         offset = 6;
char           rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  for (ccsemver_id_t * iter = &id; iter; iter = iter->next) @{
    printf("numeric?=%d, num=%ld, len=%lu, raw=%s\n",
           (int)iter->numeric, iter->num, iter->len, iter->raw);
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha.7
numeric?=1, num=7, len=1, raw=7
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a compound identifier with appended build metadata


The following example parses the compound identifier @samp{1.2.3-alpha.7+x86-64}:

@example
const char     input_str[] = "1.2.3-alpha.7+x86-64";
ccsemver_id_t  id;
size_t         offset = 6;
char           rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  for (ccsemver_id_t * iter = &id; iter; iter = iter->next) @{
    printf("numeric?=%d, num=%ld, len=%lu, raw=%s\n",
           (int)iter->numeric, iter->num, iter->len, iter->raw);
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha.7+x86-64
numeric?=1, num=7, len=1, raw=7+x86-64
@end example

@noindent
notice how parsing the identifier stops at the character @samp{+}, which delimits the beginning of
the build metadata.

@c page
@node identifiers writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_id_write (ccsemver_id_t const * @var{id}, char * @var{output_buf}, size_t @var{output_len})
Serialise the identifier @var{id} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full identifier serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising an identifier


The following example serialises a compound identifier:

@example
static const char     input_str[] = "1.2.3-alpha.7";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_id_write(&id, \
      buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, id=",
      strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
the code prints:

@example
len=13, actual_count=13, id=1.2.3-alpha.7
@end example

@c page
@node identifiers comparing
@section Identifiers comparison


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_id_comp (ccsemver_id_t const * @vari{id}, ccsemver_id_t const * @varii{id})
Compare the numeric components of the given identifiers.  Return @code{-1} if @vari{id} is less than
@varii{id}; return @code{0} if @vari{id} is equal to @varii{id}; return @code{+1} if @vari{id} is
greater than @varii{id}.

An empty identifier is less than any other identifier but the empty one; two empty identifiers are
equal.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: comparing identifiers


The following example compares two identifiers:

@example
static const char     input_str_A[] = "1.2.3";
static const char     input_str_B[] = "1.2.4";
ccsemver_id_t   id_A, id_B;
size_t        offset_A = 0, offset_B = 0;
char          rv;

rv = ccsemver_id_read(&id_A, \
    input_str_A, strlen(input_str_A), &offset_A);
if (0 == rv) @{
  rv = ccsemver_id_read(&id_B, \
      input_str_B, strlen(input_str_B), &offset_B);
  if (0 == rv) @{
    char    compar = ccsemver_id_comp(&id_A, &id_B);
    printf("compar=%d\n", (int)compar);
  @}
  ccsemver_id_dtor(&id_B);
@}
ccsemver_id_dtor(&id_A);
@end example

@noindent
and the code prints:

@example
compar=-1
@end example

@c page
@node utilities
@chapter Utility functions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun size_t ccsemver_id_fwrite (const ccsemver_id_t * @var{id}, FILE * @var{stream})
Serialise the referenced identifier to the given @var{stream}.  When successful: return the number
of characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_sv_fwrite (const ccsemver_sv_t * @var{sv}, FILE * @var{stream})
Serialise the referenced version to the given @var{stream}.  When successful: return the number of
characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_comp_fwrite (const ccsemver_comp_t * @var{cmp}, FILE * @var{stream})
Serialise the referenced comparator to the given @var{stream}.  When successful: return the number
of characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_range_fwrite (const ccsemver_range_t * @var{rn}, FILE * @var{stream})
Serialise the referenced range to the given @var{stream}.  When successful: return the number of
characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun {char const *} ccsemver_op_string (ccsemver_op_t @var{op})
Return a statically allocated @asciiz{} string representing the name of @var{op}.  Useful for
debugging purposes.
@end deftypefun

@c page
@node Package License
@appendix Unlicense


This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in
source code form or as a compiled binary, for any purpose, commercial or non--commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any
and all copyright interest in the software to the public domain. We make this dedication for the
benefit of the public at large and to the detriment of our heirs and successors. We intend this
dedication to be an overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to @url{http://unlicense.org}.

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCStructs is available at:

@center @url{https://github.com/marcomaggi/ccstructs/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

This package is a fork of the project Libsv by @value{ORIGIN_AUTHOR}; the original project is
available at:

@center @value{OriginUrl}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
