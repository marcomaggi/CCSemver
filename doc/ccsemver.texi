\input texinfo.tex
@c %**start of header
@setfilename ccsemver.info
@settitle CCSemver
@c %**end of header

@include version.texi
@include macros.texi
@include ccexceptions-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCSemver

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCSemver

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccsemver

@c To be used as @value{ORIGIN_AUTHOR} whenever we need to include the list of
@c authors of this document.
@set ORIGIN_AUTHOR              Lucas Abel

@c To be used as @value{ORIGIN_AUTHOR_URL} whenever we need to include the
@c email of the *single* author of this document.
@set ORIGIN_AUTHOR_URL          @email{https://github.com/uael}

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2017-2020

@c ------------------------------------------------------------

@set CCExceptionsVersion       0.10.0
@set CCMemoryVersion           0.3.0
@set CCStructsVersion          0.4.0
@set CCTestsVersion            0.5.0

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCSEMVER
@set PackagePkgconfigModule             ccsemver
@set PackageLibsVar                     @env{CCSEMVER_LIBS}
@set PackageCflagsVar                   @env{CCSEMVER_CFLAGS}
@c This is the stem of the library in "libccsemver.so".
@set PackageLibstem                     ccsemver
@set PackageApiPrefixLower              ccsemver_
@set PackageApiPrefixUpper              CCSEMVER_

@set PackageHeader                      ccsemver.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@set OriginUrl                 @url{https://github.com/uael/sv/}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing @emph{Semantic Versioning} for the C language.

The library supports @posix{} platforms.  The library depends on the packages:

@itemize
@item
CCExceptions, at least version @value{CCExceptionsVersion};

@item
CCMemory, at least version @value{CCMemoryVersion};

@item
CCStructs, at least version @value{CCStructsVersion};
@end itemize

To run the test suite, the package depends upon the packages:

@itemize
@item
CCTests, at least version @value{CCTestsVersion}.
@end itemize

The package is distributed under the terms of the Unlicense, see @url{http://unlicense.org}.

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

This package is a fork of the project Libsv by @value{ORIGIN_AUTHOR}; the original project is
available at:

@center @value{OriginUrl}

The specification of @emph{Semantic Versioning} is publicly available at the site:

@center @url{https://semver.org/}

@noindent
under the terms of the @url{https://creativecommons.org/licenses/by/3.0/, Creative Commons --- CC BY
3.0}.  The @emph{Semantic Versioning} specification is authored by Tom Preston--Werner, inventor of
Gravatars and cofounder of GitHub.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{ORIGIN_AUTHOR}, @value{AUTHOR}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccsemver: (ccsemver).               CCSemver, semantic versioning for C.
@end direntry
@end ifinfo

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* spec::                        @emph{Semantic Versioning} specification.
* ext::                         Specification extensions.
* init::                        Library initialisation.
* version::                     Version functions.
* conditions::                  Exceptional condition objects.
* input::                       Parser input specification.
* semvers::                     Parsing semantic versions.
* comparators::                 Parsing and using comparators.
* ranges::                      Parsing and using ranges.
* numbers::                     Parsing numbers and numeric components.
* identifiers::                 Parsing identifiers.
* utilities::                   Utility functions.

Appendices

* Package License::             Unlicense.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing @emph{Semantic Versioning} for the C language.  A @dfn{semantic version} is described
by the specification @samp{v2.0.0} included in this document, @ref{spec, @emph{Semantic Versioning}
specification}.

The library supports @posix{} platforms.  The library depends on the packages:

@itemize
@item
CCExceptions, at least version @value{CCExceptionsVersion};

@item
CCMemory, at least version @value{CCMemoryVersion};

@item
CCStructs, at least version @value{CCStructsVersion};
@end itemize

To run the test suite, the package depends upon the packages:

@itemize
@item
CCTests, at least version @value{CCTestsVersion}.
@end itemize

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, the whole @api{} is available by including the
single header file @value{PackageHeaderFile}.  All the function names in the @api{} are prefixed
with @code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

@strong{Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccsemver_init}}.

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            Generated function names.
* overview exceptions::         Handling exceptional conditions.
* overview allocation::         Memory allocation for pathname instances.
@end menu

@include overview-linking.texi
@include overview-ccnames.texi
@include overview-ccexceptions.texi
@include overview-ccmemory.texi

@c page
@node spec
@chapter @emph{Semantic Versioning} specification


The specification of @emph{Semantic Versioning} is publicly available at the site:

@center @url{https://semver.org/}

@noindent
under the terms of the @url{https://creativecommons.org/licenses/by/3.0/, Creative Commons --- CC BY
3.0}.  The @emph{Semantic Versioning} specification is authored by Tom Preston--Werner, inventor of
Gravatars and cofounder of GitHub.  @value{PACKAGE} implements a parser for version 2.0.0 of the
specification; it also adds specifications for ranges.  The full text of the specification is
included here, with small formatting changes.

Given a version number @samp{MAJOR.MINOR.PATCH}, increment the:

@enumerate
@item
@samp{MAJOR} version when you make incompatible @api{} changes.

@item
@samp{MINOR} version when you add functionality in a backwards--compatible manner.

@item
@samp{PATCH} version when you make backwards--compatible bug fixes.
@end enumerate

Additional labels for pre--release and build metadata are available as extensions to the
@samp{MAJOR.MINOR.PATCH} format.

@menu
* spec introduction::           Introduction.
* spec semver::                 Semantic Versioning Specification (SemVer).
* spec why::                    Why use semantic versioning?
* spec faq::                    Frequently asked questions.
@end menu

@c page
@node spec introduction
@section Introduction


In the world of software management there exists a dreaded place called ``dependency hell''.  The
bigger your system grows and the more packages you integrate into your software, the more likely you
are to find yourself, one day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly become a nightmare.
If the dependency specifications are too tight, you are in danger of version lock (the inability to
upgrade a package without having to release new versions of every dependent package).  If
dependencies are specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).  Dependency hell is where you
are when version lock and/or version promiscuity prevent you from easily and safely moving your
project forward.

As a solution to this problem, I propose a simple set of rules and requirements that dictate how
version numbers are assigned and incremented.  These rules are based on but not necessarily limited
to pre--existing widespread common practices in use in both closed and open--source software.  For
this system to work, you first need to declare a public @api{}.  This may consist of documentation
or be enforced by the code itself.  Regardless, it is important that this @api{} be clear and
precise.  Once you identify your public @api{}, you communicate changes to it with specific
increments to your version number.  Consider a version format of @samp{X.Y.Z}
(@samp{MAJOR.MINOR.PATCH}).  Bug fixes not affecting the @api{} increment the patch version,
backwards compatible @api{} additions/changes increment the minor version, and backwards
incompatible @api{} changes increment the major version.

I call this system @dfn{Semantic Versioning}.  Under this scheme, version numbers and the way they
change convey meaning about the underlying code and what has been modified from one version to the
next.

@c page
@node spec semver
@section Semantic Versioning Specification (SemVer)


The key words ``MUST'', ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL NOT'', ``SHOULD'', ``SHOULD
NOT'', ``RECOMMENDED'', ``MAY'', and ``OPTIONAL'' in this document are to be interpreted as
described in @rfc{} 2119.

@enumerate
@item
Software using @emph{Semantic Versioning} MUST declare a public @api{}.  This @api{} could be
declared in the code itself or exist strictly in documentation.  However it is done, it should be
precise and comprehensive.

@item
A normal version number MUST take the form @samp{X.Y.Z} where @samp{X}, @samp{Y}, and @samp{Z} are
non--negative integers, and MUST NOT contain leading zeroes.  @samp{X} is the major version,
@samp{Y} is the minor version, and @samp{Z} is the patch version.  Each element MUST increase
numerically.  For instance: @samp{1.9.0 -> 1.10.0 -> 1.11.0}.

@item
Once a versioned package has been released, the contents of that version MUST NOT be modified.  Any
modifications MUST be released as a new version.

@item
Major version zero (@samp{0.y.z}) is for initial development.  Anything may change at any time.  The
public @api{} should not be considered stable.

@item
Version @samp{1.0.0} defines the public @api{}.  The way in which the version number is incremented
after this release is dependent on this public @api{} and how it changes.

@item
Patch version @samp{Z} (@samp{x.y.Z | x > 0}) MUST be incremented if only backwards compatible bug
fixes are introduced.  A bug fix is defined as an internal change that fixes incorrect behavior.

@item
Minor version @samp{Y} (@samp{x.Y.z | x > 0}) MUST be incremented if new, backwards compatible
functionality is introduced to the public @api{}.  It MUST be incremented if any public @api{}
functionality is marked as deprecated.  It MAY be incremented if substantial new functionality or
improvements are introduced within the private code.  It MAY include patch level changes.  Patch
version MUST be reset to @samp{0} when minor version is incremented.

@item
Major version @samp{X} (@samp{X.y.z | X > 0}) MUST be incremented if any backwards incompatible
changes are introduced to the public @api{}.  It MAY include minor and patch level changes.  Patch
and minor version MUST be reset to @samp{0} when major version is incremented.

@item
A pre--release version MAY be denoted by appending a hyphen and a series of dot separated
identifiers immediately following the patch version.  Identifiers MUST comprise only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}.  Identifiers MUST NOT be empty.  Numeric identifiers
MUST NOT include leading zeroes.  Pre--release versions have a lower precedence than the associated
normal version.  A pre--release version indicates that the version is unstable and might not satisfy
the intended compatibility requirements as denoted by its associated normal version.  Examples:
@samp{1.0.0-alpha}, @samp{1.0.0-alpha.1}, @samp{1.0.0-0.3.7}, @samp{1.0.0-x.7.z.92}.

@item
Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers
immediately following the patch or pre--release version.  Identifiers MUST comprise only @ascii{}
alphanumerics and hyphen @samp{[0-9A-Za-z-]}.  Identifiers MUST NOT be empty.  Build metadata SHOULD
be ignored when determining version precedence.  Thus two versions that differ only in the build
metadata, have the same precedence.  Examples: @samp{1.0.0-alpha+001}, @samp{1.0.0+20130313144700},
@samp{1.0.0-beta+exp.sha.5114f85}.

@item
Precedence refers to how versions are compared to each other when ordered.  Precedence MUST be
calculated by separating the version into major, minor, patch and pre-release identifiers in that
order (build metadata does not figure into precedence).  Precedence is determined by the first
difference when comparing each of these identifiers from left to right as follows: @samp{MAJOR},
@samp{MINOR}, and @samp{PATCH} versions are always compared numerically.  Example:

@example
1.0.0 < 2.0.0 < 2.1.0 < 2.1.1
@end example

When @samp{MAJOR}, @samp{MINOR}, and @samp{PATCH} are equal, a pre--release version has lower
precedence than a normal version.  Example:

@example
1.0.0-alpha < 1.0.0
@end example

Precedence for two pre--release versions with the same @samp{MAJOR}, @samp{MINOR}, and @samp{PATCH}
version MUST be determined by comparing each dot separated identifier from left to right until a
difference is found as follows: identifiers consisting of only digits are compared numerically and
identifiers with letters or hyphens are compared lexically in @ascii{} sort order.  Numeric
identifiers always have lower precedence than non--numeric identifiers.  A larger set of
pre--release fields has a higher precedence than a smaller set, if all of the preceding identifiers
are equal.  Example:

@example
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
< 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0
@end example
@end enumerate

@c page
@node spec why
@section Why use semantic versioning?


This is not a new or revolutionary idea.  In fact, you probably do something close to this already.
The problem is that ``close'' isn't good enough.  Without compliance to some sort of formal
specification, version numbers are essentially useless for dependency management.  By giving a name
and clear definition to the above ideas, it becomes easy to communicate your intentions to the users
of your software.  Once these intentions are clear, flexible (but not too flexible) dependency
specifications can finally be made.

A simple example will demonstrate how @emph{Semantic Versioning} can make dependency hell a thing of
the past.  Consider a library called ``Firetruck''.  It requires a Semantically Versioned package
named ``Ladder''.  At the time that Firetruck is created, Ladder is at version @samp{3.1.0}.  Since
Firetruck uses some functionality that was first introduced in @samp{3.1.0}, you can safely specify
the Ladder dependency as greater than or equal to @samp{3.1.0} but less than @samp{4.0.0}.  Now,
when Ladder version @samp{3.1.1} and @samp{3.2.0} become available, you can release them to your
package management system and know that they will be compatible with existing dependent software.

As a responsible developer you will, of course, want to verify that any package upgrades function as
advertised.  The real world is a messy place; there's nothing we can do about that but be vigilant.
What you can do is let @emph{Semantic Versioning} provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you time and hassle.

If all of this sounds desirable, all you need to do to start using @emph{Semantic Versioning} is to
declare that you are doing so and then follow the rules.  Link to this website from your README so
others know the rules and can benefit from them.

@c page
@node spec faq
@section Frequently asked questions


@enumerate
@item How should I deal with revisions in the @samp{0.y.z} initial development phase?

The simplest thing to do is start your initial development release at @samp{0.1.0} and then
increment the minor version for each subsequent release.

@c ------------------------------------------------------------------------

@item How do I know when to release @samp{1.0.0}?

If your software is being used in production, it should probably already be @samp{1.0.0}.  If you
have a stable @api{} on which users have come to depend, you should be @samp{1.0.0}.  If you're
worrying a lot about backwards compatibility, you should probably already be @samp{1.0.0}.

@c ------------------------------------------------------------------------

@item Doesn't this discourage rapid development and fast iteration?

Major version zero is all about rapid development.  If you're changing the @api{} every day you
should either still be in version @samp{0.y.z} or on a separate development branch working on the
next major version.

@c ------------------------------------------------------------------------

@item If even the tiniest backwards incompatible changes to the public @api{} require a major version bump, won't I end up at version @samp{42.0.0} very rapidly?

This is a question of responsible development and foresight.  Incompatible changes should not be
introduced lightly to software that has a lot of dependent code.  The cost that must be incurred to
upgrade can be significant.  Having to bump major versions to release incompatible changes means
you'll think through the impact of your changes, and evaluate the cost/benefit ratio involved.

@c ------------------------------------------------------------------------

@item Documenting the entire public @api{} is too much work!

It is your responsibility as a professional developer to properly document software that is intended
for use by others.  Managing software complexity is a hugely important part of keeping a project
efficient, and that's hard to do if nobody knows how to use your software, or what methods are safe
to call.  In the long run, @emph{Semantic Versioning}, and the insistence on a well defined public
@api{} can keep everyone and everything running smoothly.

@c ------------------------------------------------------------------------

@item What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you've broken the @emph{Semantic Versioning} spec, fix the problem and
release a new minor version that corrects the problem and restores backwards compatibility.  Even
under this circumstance, it is unacceptable to modify versioned releases.  If it's appropriate,
document the offending version and inform your users of the problem so that they are aware of the
offending version.

@c ------------------------------------------------------------------------

@item What should I do if I update my own dependencies without changing the public @api{}?

That would be considered compatible since it does not affect the public @api{}.  Software that
explicitly depends on the same dependencies as your package should have their own dependency
specifications and the author will notice any conflicts.  Determining whether the change is a patch
level or minor level modification depends on whether you updated your dependencies in order to fix a
bug or introduce new functionality.  I would usually expect additional code for the latter instance,
in which case it's obviously a minor level increment.

@c ------------------------------------------------------------------------

@item What if I inadvertently alter the public @api{} in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment.  If you have a huge audience that will be drastically impacted by changing
the behavior back to what the public @api{} intended, then it may be best to perform a major version
release, even though the fix could strictly be considered a patch release.  Remember, @emph{Semantic
Versioning} is all about conveying meaning by how the version number changes.  If these changes are
important to your users, use the version number to inform them.

@c ------------------------------------------------------------------------

@item How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and is often required to
make forward progress.  When you deprecate part of your public @api{}, you should do two things: (1)
update your documentation to let users know about the change, (2) issue a new minor release with the
deprecation in place.  Before you completely remove the functionality in a new major release there
should be at least one minor release that contains the deprecation so that users can smoothly
transition to the new @api{}.

@c ------------------------------------------------------------------------

@item Does @emph{Semantic Versioning} have a size limit on the version string?

No, but use good judgement.  A 255 character version string is probably overkill, for example.
Also, specific systems may impose their own limits on the size of the string.
@end enumerate

@c page
@node ext
@chapter Specification extensions


@value{PACKAGE} extends the specification of @emph{Semantic Versioning} with syntaxes and comparison
rules for ranges and tags.

@menu
* ext ranges::                  Ranges.
* ext tags::                    Prerelease tags.
* ext advanced::                Advanced range syntax.
@end menu

@c page
@node ext ranges
@section Ranges


A @dfn{version range} is a set of @dfn{comparators} which specify versions that satisfy the range.
A comparator is composed of an @dfn{operator} and a @dfn{version}.  The set of primitive operators
is:

@table @code
@item <
Less than.

@item <=
Less than or equal to.

@item >
Greater than.

@item >=
Greater than or equal to.

@item =
Equal.  If no operator is specified, then equality is assumed, so this operator is optional, but MAY
be included.
@end table

For example, the comparator @samp{>=1.2.7} would match the versions @samp{1.2.7}, @samp{1.2.8},
@samp{2.5.3}, and @samp{1.3.9}, but not the versions @samp{1.2.6} or @samp{1.1.0}.

Comparators can be joined by whitespace to form a @dfn{comparator set}, which is satisfied by the
@strong{intersection} of all of the comparators it includes.

A range is composed of one or more comparator sets, joined by @code{||}.  A version matches a range
if and only if every comparator in at least one of the @code{||}--separated comparator sets is
satisfied by the version.

For example, the range @samp{>=1.2.7 <1.3.0} would match the versions @samp{1.2.7}, @samp{1.2.8},
and @samp{1.2.99}, but not the versions @samp{1.2.6}, @samp{1.3.0}, or @samp{1.1.0}.

The range @samp{1.2.7 || >=1.2.9 <2.0.0} would match the versions @samp{1.2.7}, @samp{1.2.9}, and
@samp{1.4.6}, but not the versions @samp{1.2.8} or @samp{2.0.0}.

@c page
@node ext tags
@section Prerelease tags


If a version has a prerelease tag (for example @samp{1.2.3-alpha.3}) then it will only be allowed to
satisfy comparator sets if at least one comparator with the same @code{(major, minor, patch)} tuple
also has a prerelease tag.

For example, the range @samp{>1.2.3-alpha.3} would be allowed to match the version
@samp{1.2.3-alpha.7}, but it would @strong{not} be satisfied by @samp{3.4.5-alpha.9}, even though
@samp{3.4.5-alpha.9} is technically ``greater than'' @samp{1.2.3-alpha.3} according to the
@emph{Semantic Versioning} sort rules.  The version range only accepts prerelease tags on the
@samp{1.2.3} version.  The version @samp{3.4.5} @strong{would} satisfy the range, because it does
not have a prerelease tag, and @samp{3.4.5} is greater than @samp{1.2.3-alpha.7}.

The purpose for this behavior is twofold.

@itemize
@item
Prerelease versions frequently are updated very quickly, and contain many breaking changes that are
(by the author's design) not yet fit for public consumption.  Therefore, by default, they are
excluded from range matching semantics.

@item
A user who has opted into using a prerelease version has clearly indicated the intent to use
@strong{that specific} set of alpha/beta/rc versions.  By including a prerelease tag in the range,
the user is indicating that they are aware of the risk.  However, it is still not appropriate to
assume that they have opted into taking a similar risk on the @strong{next} set of prerelease
versions.
@end itemize

@c page
@node ext advanced
@section Advanced range syntax


Advanced range syntax desugars to primitive comparators in deterministic ways.  Advanced ranges may
be combined in the same way as primitive comparators using white space or @code{||}.

@c ------------------------------------------------------------------------

@subsubheading Hyphen ranges @samp{X.Y.Z - A.B.C}


Specifies an inclusive set.

@table @asis
@item @samp{1.2.3 - 2.3.4} := @samp{>=1.2.3 <=2.3.4}
@end table

If a partial version is provided as the first version in the inclusive range, then the missing
pieces are replaced with zeroes.

@table @asis
@item @samp{1.2 - 2.3.4} := @samp{>=1.2.0 <=2.3.4}
@end table

If a partial version is provided as the second version in the inclusive range, then all versions
that start with the supplied parts of the tuple are accepted, but nothing that would be greater than
the provided tuple parts.

@table @asis
@item @samp{1.2.3 - 2.3} := @samp{>=1.2.3 <2.4.0}

@item @samp{1.2.3 - 2} := @samp{>=1.2.3 <3.0.0}
@end table

@c ------------------------------------------------------------------------

@subsubheading X-Ranges @samp{1.2.x} @samp{1.X} @samp{1.2.*} @samp{*}


Any of @samp{X}, @samp{x}, or @samp{*} may be used to ``stand in'' for one of the numeric values in
the @code{(major, minor, patch)} tuple.

@table @asis
@item @samp{*} := @samp{>=0.0.0}
Any version satisfies.

@item @samp{1.x} := @samp{>=1.0.0 <2.0.0}
Matching major version.

@item @samp{1.2.x} := @samp{>=1.2.0 <1.3.0}
Matching major and minor versions.
@end table

A partial version range is treated as an X-Range, so the special character is in fact optional.

@table @asis
@item Empty string := @samp{*} := @samp{>=0.0.0}

@item @samp{1} := @samp{1.x.x} := @samp{>=1.0.0 <2.0.0}

@item @samp{1.2} := @samp{1.2.x} := @samp{>=1.2.0 <1.3.0}
@end table

@c ------------------------------------------------------------------------

@subsubheading Tilde ranges @samp{~1.2.3} @samp{~1.2} @samp{~1}

Allows patch--level changes if a minor version is specified on the comparator.  Allows minor-level
changes if not.

@table @asis
@item @samp{~1.2.3} := @samp{>=1.2.3 <1.(2+1).0} := @samp{>=1.2.3 <1.3.0}

@item @samp{~1.2} := @samp{>=1.2.0 <1.(2+1).0} := @samp{>=1.2.0 <1.3.0}
Same as @samp{1.2.x}.

@item @samp{~1} := @samp{>=1.0.0 <(1+1).0.0} := @samp{>=1.0.0 <2.0.0}
Same as @samp{1.x}.

@item @samp{~0.2.3} := @samp{>=0.2.3 <0.(2+1).0} := @samp{>=0.2.3 <0.3.0}

@item @samp{~0.2} := @samp{>=0.2.0 <0.(2+1).0} := @samp{>=0.2.0 <0.3.0}
Same as @samp{0.2.x}.

@item @samp{~0} := @samp{>=0.0.0 <(0+1).0.0} := @samp{>=0.0.0 <1.0.0}
Same as @samp{0.x}.

@item @samp{~1.2.3-beta.2} := @samp{>=1.2.3-beta.2 <1.3.0}
Note that prereleases in the @samp{1.2.3} version will be allowed, if they are greater than or equal
to @samp{beta.2}.  So, @samp{1.2.3-beta.4} would be allowed, but @samp{1.2.4-beta.2} would not,
because it is a prerelease of a different @code{(major, minor, patch)} tuple.
@end table

@c ------------------------------------------------------------------------

@subsubheading Caret ranges @samp{^1.2.3} @samp{^0.2.5} @samp{^0.0.4}


Allow changes that do not modify the left--most non--zero digit in the @code{(major, minor, patch)}
tuple.  In other words, this allows patch and minor updates for versions @samp{1.0.0} and above,
patch updates for versions @samp{0.X >=0.1.0}, and @strong{no} updates for versions @samp{0.0.X}.

Many authors treat a @samp{0.x} version as if the @samp{x} were the major ``breaking change''
indicator.

Caret ranges are ideal when an author may make breaking changes between @samp{0.2.4} and
@samp{0.3.0} releases, which is a common practice.  However, it presumes that there will
@strong{not} be breaking changes between @samp{0.2.4} and @samp{0.2.5}.  It allows for changes that
are presumed to be additive (but non--breaking), according to commonly observed practices.

@table @asis
@item @samp{^1.2.3} := @samp{>=1.2.3 <2.0.0}

@item @samp{^0.2.3} := @samp{>=0.2.3 <0.3.0}

@item @samp{^0.0.3} := @samp{>=0.0.3 <0.0.4}

@item @samp{^1.2.3-beta.2} := @samp{>=1.2.3-beta.2 <2.0.0}
Note that prereleases in the @samp{1.2.3} version will be allowed, if they are greater than or equal
to @samp{beta.2}.  So, @samp{1.2.3-beta.4} would be allowed, but @samp{1.2.4-beta.2} would not,
because it is a prerelease of a different @code{(major, minor, patch)} tuple.

@item @samp{^0.0.3-beta} := @samp{>=0.0.3-beta <0.0.4}
Note that prereleases in the @samp{0.0.3} version @strong{only} will be allowed, if they are greater
than or equal to @samp{beta}.  So, @samp{0.0.3-pr.2} would be allowed.
@end table

When parsing caret ranges, a missing @code{patch} value desugars to the number @samp{0}, but will
allow flexibility within that value, even if the major and minor versions are both @samp{0}.

@table @asis
@item @samp{^1.2.x} := @samp{>=1.2.0 <2.0.0}

@item @samp{^0.0.x} := @samp{>=0.0.0 <0.1.0}

@item @samp{^0.0} := @samp{>=0.0.0 <0.1.0}
@end table

A missing @code{minor} and @code{patch} values will desugar to zero, but also allow flexibility
within those values, even if the major version is zero.

@table @asis
@item @samp{^1.x} := @samp{>=1.0.0 <2.0.0}

@item @samp{^0.x} := @samp{>=0.0.0 <1.0.0}
@end table

@c page
@node init
@chapter Library initialisation


@deftypefun void ccsemver_library_init (void)
Initialises the internal structures of the library.  It is fine to call this function multiple
times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccsemver_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccsemver_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccsemver_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccsemver_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@menu
* conditions parser error::     Parser error.
* conditions parser input::     Parser input errors.
* conditions parser invalid::   Invalid input to parser.
@end menu

@c page
@node conditions parser error
@section Parser error


The @dfn{parser error exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting to parse an invalid input string.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_error,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_error}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_error}


@CCEConditionObjectPredicate{ccsemver,parser_error}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_error}

@c page
@node conditions parser input
@section Parser input errors


@menu
* conditions parser input no input::  No input available while parsing.
* conditions parser input empty::     Input is empty while parsing.
* conditions parser input eoi::       Unexpected end-of-input while parsing.
* conditions parser input offset::    Invalid input offset while parsing.
@end menu

@c page
@node conditions parser input no input
@subsection No input available while parsing


The @dfn{no input exceptional--condition object} has the purpose of describing an exceptional
condition caused by finding no available input while parsing semantic version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_no_input,ccsemver_descriptor_parser_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_no_input}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_no_input}


@CCEConditionObjectPredicate{ccsemver,parser_no_input}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_no_input}

@c page
@node conditions parser input empty
@subsection empty input while parsing


The @dfn{empty input exceptional--condition object} has the purpose of describing an exceptional
condition caused by empty input while parsing semantic version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_empty_input,ccsemver_descriptor_parser_no_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_empty_input}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_empty_input}


@CCEConditionObjectPredicate{ccsemver,parser_empty_input}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_empty_input}

@c page
@node conditions parser input eoi
@subsection Unexpected end--of--input while parsing


The @dfn{unexpected end--of--input exceptional--condition object} has the purpose of describing an
exceptional condition caused by an unexpected end--of--input while parsing semantic version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_end_of_input,ccsemver_descriptor_parser_no_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_end_of_input}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_end_of_input}


@CCEConditionObjectPredicate{ccsemver,parser_end_of_input}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_end_of_input}

@c page
@node conditions parser input offset
@subsection Invalid input offset while parsing


The @dfn{invalid input offset exceptional--condition object} has the purpose of describing an
exceptional condition caused by attempting to access the input string at an invalid offset, while
parsing semantic version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_invalid_input_offset,ccsemver_descriptor_parser_no_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_invalid_input_offset}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_invalid_input_offset}


@CCEConditionObjectPredicate{ccsemver,parser_invalid_input_offset}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_invalid_input_offset}

@c page
@node conditions parser invalid
@section Invalid input to parser


@menu
* conditions parser invalid number::   Expected number.
* conditions parser invalid numcomp::  Expected numeric component.
* conditions parser invalid xnumcomp:: Expected X-Range numeric component.
* conditions parser invalid id::       Expected identifier.
* conditions parser invalid numrange:: Number out of range.
@end menu

@c page
@node conditions parser invalid number
@subsection Expected number


The @dfn{expected number exceptional--condition object} has the purpose of describing an exceptional
condition caused by invalid input when a number was expected, while parsing semantic version
strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_expected_number,ccsemver_descriptor_parser_invalid_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_expected_number}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_expected_number}


@CCEConditionObjectPredicate{ccsemver,parser_expected_number}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_expected_number}

@c page
@node conditions parser invalid numcomp
@subsection Expected numeric component


The @dfn{expected numeric component exceptional--condition object} has the purpose of describing an
exceptional condition caused by invalid input when a numeric component was expected, while parsing
semantic version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_expected_numeric_component,ccsemver_descriptor_parser_invalid_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_expected_numeric_component}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_expected_numeric_component}


@CCEConditionObjectPredicate{ccsemver,parser_expected_numeric_component}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_expected_numeric_component}

@c page
@node conditions parser invalid xnumcomp
@subsection Expected X-Range numeric component


The @dfn{expected X-Range numeric component exceptional--condition object} has the purpose of
describing an exceptional condition caused by invalid input when a X-Range numeric component was
expected, while parsing semantic version strings.  This exception is raised, for example, when
parsing a range and a numeric component is present after a X-Range one; for example @samp{X.X.X} is
a valid range, while @samp{X.2} and @samp{X.X.3} are invalid because @samp{2} and @samp{3} would be
ignored.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_expected_xrange_numeric_component,ccsemver_descriptor_parser_invalid_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_expected_xrange_numeric_component}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_expected_xrange_numeric_component}


@CCEConditionObjectPredicate{ccsemver,parser_expected_xrange_numeric_component}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_expected_xrange_numeric_component}

@c page
@node conditions parser invalid id
@subsection Expected identifier


The @dfn{expected identifier exceptional--condition object} has the purpose of describing an
exceptional condition caused by invalid input when a identifier was expected, while parsing semantic
version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_expected_identifier,ccsemver_descriptor_parser_invalid_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_expected_identifier}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_expected_identifier}


@CCEConditionObjectPredicate{ccsemver,parser_expected_identifier}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_expected_identifier}

@c page
@node conditions parser invalid numrange
@subsection Number out of range


The @dfn{number out of range exceptional--condition object} has the purpose of describing an
exceptional condition caused by a attempting to parse a number and finding it out of its allowed
range, while parsing semantic version strings.

All the following definitions are accessible from the header file @file{ccsemver.h}.


@CCEDescriptorTypedef{ccsemver,parser_number_out_of_range,ccsemver_descriptor_parser_invalid_input_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccsemver,parser_number_out_of_range}
Type of data structure representing an exceptional--condition object.
@end deftp


@CCEConditionObjectNewNoArgs{ccsemver,parser_number_out_of_range}


@CCEConditionObjectPredicate{ccsemver,parser_number_out_of_range}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccsemver,parser_number_out_of_range}

@c page
@node input
@chapter Parser input specification


Every parser function accepts as argument a pointer to @objtype{ccsemver_input_t} to keep track of
which input characters have been consumed.  The whole parser input strings are meant to be loaded in
memory.  Usage example:

@example
char const * const str    = "1.2.3-alpha.1+x86-64";
size_t const       len    = strlen(str);
size_t const       offset = 0;
ccsemver_input_t   input  = ccsemver_input_new(str, len, offset);
@end example


@deftp {Struct Typedef} ccsemver_input_t
Type of @code{struct} representing the input for the parser functions; the input is meant to be a
string in @ascii{} format.  It has the following public fields:

@table @code
@item char const * const str
Pointer to the first character in the input string.  Parser functions never mutate this value.

@item size_t const len
Number of characters in the input string.  Parser functions never mutate this value.

@item size_t off
Offset of the next character to parse in the input string.  This value is mutated by every parser
function.  The field @code{off} is both an input and output parameter:

@itemize
@item
Upon entering a parser function: @code{off} is the offset of the first character to parse in
@code{str}.

@item
When the parser function returns successfully: @code{off} is the offset of the first non--parsed
character; further parsing operations can use such value as input.

@item
When the function returns unsuccessfully: @code{off} is invalid.
@end itemize
@end table

Unless otherwise specified, for every parser function: if the input string is empty (@code{len} is
zero), the function returns unsuccessfully.
@end deftp

@c ------------------------------------------------------------------------

@subsubheading Constructors


@deftypefun ccsemver_input_t ccsemver_input_new (char const * @var{str}, size_t @var{len}, size_t @var{off})
Build and return a new instance of @objtype{ccsemver_input_t}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Predicates


@deftypefun bool ccsemver_input_is_empty (ccsemver_input_t * @var{input})
Return @ctrue{} if the input string has zero length; otherwise return @cfalse{}.  Notice that ``zero
length'' is different from ``no more input''.
@end deftypefun


@deftypefun bool ccsemver_input_more (ccsemver_input_t * @var{input})
Return @ctrue{} if there is more input to be parsed; return @cfalse{} if all the input has been
processed.
@end deftypefun


@deftypefun bool ccsemver_input_at_end (ccsemver_input_t * @var{input})
Return @ctrue{} if there is @strong{no} more input to be parsed; return @cfalse{} if there is more
input to be processed.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Operations


@deftypefun char ccsemver_input_next (ccsemver_input_t * @var{input})
Return the next character to parse.  Do @strong{not} mutate the field @code{off}.
@end deftypefun


@deftypefun void ccsemver_input_step (ccsemver_input_t * @var{input})
Increment the field @code{off}.
@end deftypefun

@c page
@node semvers
@chapter Parsing semantic versions


According to @emph{Semantic Versioning} version @samp{v2.0.0}, @dfn{semantic versions} are strings
in @ascii{} encoding with the following format:

@example
1.2.3-alpha.1-beta.2+x86-64
@end example

@noindent
where:

@table @samp
@item 1
Is the major version number; it is mandatory; it must not have leading zeros.

@item 2
Is the minor version number; it is mandatory; it must not have leading zeros.

@item 3
Is the patch level; it is mandatory; it must not have leading zeros.

@item -alpha.1-beta.2
Is the prerelease tag; it is optional.  The leading dash character is the separator: if a dash is
present after the patch level, there must be a prerelease tag.  Prerelease tags cannot be empty:
either there is a prerelease tag or there is not.

@item +x86-64
Is the build metadata; it is optional.  The leading plus character is the separator: if a plus is
present after the patch level or the prerelease tag, there must be a build metadata.  The build
metadata cannot be empty: either there is a build metadata tag or there is not.
@end table

Other examples of valid semantic versions:

@example
1.2.3
1.2.3-alpha.1-beta.2
1.2.3+x86-64
@end example

@menu
* semvers typedefs::            Type definitions.
* semvers reading::             Parsing from a string.
* semvers writing::             Writing to a string.
* semvers comparing::           Versions comparison.
@end menu

@c page
@node semvers typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_sv_t
Type of data structures representing parsed versions.  Instances of this structure are initialised
with @cfunc{ccsemver_ctor}.  Instances of this structure are finalised with @cfunc{ccsemver_dtor}.

The semantic versions @api{} does @strong{not} duplicate the input strings.

It has the following public fields:

@table @code
@item long major
An integer representing the major version number.

@item long minor
An integer representing the minor version number.

@item long patch
An integer representing the patch level.

@item ccsemver_id_t prerelease
An identifier representing the prerelease tag.

@item ccsemver_id_t build
An identifier representing the build metadata.

@item size_t len
The number of characters in the input string that where parsed to form this version.

@item char const * raw
Pointer to the character in the input string representing the first character of this component.
This pointer is valid as long as the input string handed to the constructor function is not mutated.
@end table
@end deftp


@deftypefun void ccsemver_ctor (ccsemver_sv_t * @var{sv})
Initialise to empty an already allocated data structure representing a parsed version.  Every call
to this function must be matched by a call to @cfunc{ccsemver_dtor}:

@example
ccsemver_sv_t        sv;

ccsemver_ctor(&sv);
@{
  /* Do something with "sv" here. */
@}
ccsemver_dtor(&sv);
@end example
@end deftypefun


@deftypefun void ccsemver_dtor (ccsemver_sv_t * @var{sv})
Finalise to empty a data structure representing a parsed version; calls to this function must match
a previous call to @cfunc{ccsemver_ctor} or @cfunc{ccsemver_read}.

All the resources associated to @var{sv} are released, but the structure itself.  The following code
is correct:

@example
ccsemver_sv_t        sv;

ccsemver_ctor(&sv);
@{
  /* Do something with "sv" here. */
@}
ccsemver_dtor(&sv);
@end example

@noindent
the following code is also correct:

@example
ccsemver_sv_t *      svp;

svp = malloc(sizeof(ccsemver_sv_t));
assert(NULL != svp);
@{
  ccsemver_ctor(svp);
  @{
    /* Do something with "svp" here. */
  @}
  ccsemver_dtor(svp);
@}
free(svp);
@end example
@end deftypefun

@c page
@node semvers reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_read (ccsemver_sv_t * @var{sv}, ccsemver_input_t * @var{input})
Parse input expecting a semantic version specification.  When successful: the return value is
@code{0}.  If an error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{sv}; the
structure is first initialised with @cfunc{ccsemver_ctor}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_dtor} to @var{sv}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a numeric version

The following example parses the numeric version @samp{1.2.3}:

@example
char const            input_str[] = "1.2.3";
ccsemver_input_t      input =
  ccsemver_input_new(input_str, strlen(input_str), 0);
ccsemver_sv_t            sv;
char                  rv;

rv = ccsemver_read(&sv, &input);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         sv.major, sv.minor, sv.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&sv.prerelease, stdout);
  printf(", build=");
  ccsemver_id_fwrite(&sv.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&sv);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=, build=
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a tagged version

The following example parses the version @samp{1.2.3-alpha.7}, which has
a prerelease tag:

@example
char const    input_str[] = "1.2.3-alpha.7";
ccsemver_input_t      input =
  ccsemver_input_new(input_str, strlen(input_str), 0);
ccsemver_sv_t            sv;
char                  rv;

rv = ccsemver_read(&sv, &input);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         sv.major, sv.minor, sv.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&sv.prerelease, stdout);
  printf(", build=");
  ccsemver_id_fwrite(&sv.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&sv);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=alpha.7, build=
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a full version

The following example parses the version @samp{1.2.3-alpha.7+x86-64},
which has both a prerelease tag and build metadata:

@example
char const    input_str[] = "1.2.3-alpha.7+x86-64";
ccsemver_sv_t      version;
size_t        input_off = 0;
char          rv;

rv = ccsemver_read(&version, input_str, strlen(input_str), &input_off);
if (0 == rv) @{
  printf("major=%ld, minor=%ld, patch=%ld, ",
         version.major, version.minor, version.patch);
  printf("prerelease=");
  ccsemver_id_fwrite(&version.prerelease, stdout);
  printf(", ");
  printf("build=");
  ccsemver_id_fwrite(&version.build, stdout);
  printf("\n");
@}
ccsemver_dtor(&version);
@end example

@noindent
and it prints:

@example
major=1, minor=2, patch=3, prerelease=alpha.7, build=x86-64
@end example

@c page
@node semvers writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_write (ccsemver_sv_t const * @var{sv}, char * @var{output_buf}, size_t @var{output_len})
Serialise the version @var{sv} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full version serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a version

The following example serialises a version specification:

@example
static const char     input_str[] = "1.2.3-alpha.7";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_sv_t      version;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_read(&version, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_write(&version, \
     buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
        needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, id=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
len=13, actual_count=13, id=1.2.3-alpha.7
@end example

@c page
@node semvers comparing
@section Versions comparison


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_comp (ccsemver_sv_t const * @var{A}, ccsemver_sv_t const * @var{B})
Compare the given versions.  Return @code{-1} if @var{A} is less than @var{B}; return @code{0} if
@var{A} is equal to @var{B}; return @code{+1} if @var{A} is greater than @var{B}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: comparing versions


The following example compares two versions:

@example
static const char     input_str_A[] = "1.2.3";
static const char     input_str_B[] = "1.2.4";
ccsemver_sv_t      version_A, version_B;
size_t        offset_A = 0, offset_B = 0;
char          rv;

rv = ccsemver_read(&version_A, input_str_A,
                   strlen(input_str_A), &offset_A);
if (0 == rv) @{
  rv = ccsemver_read(&version_B, input_str_B,
                   strlen(input_str_B), &offset_B);
  if (0 == rv) @{
    char    compar = ccsemver_comp(&version_A, &version_B);
    printf("compar=%d\n", (int)compar);
  @}
  ccsemver_dtor(&version_B);
@}
ccsemver_dtor(&version_A);
@end example

@noindent
and the code prints:

@example
compar=-1
@end example

@c page
@node comparators
@chapter Parsing and using comparators


The comparators @api{} does @strong{not} duplicate the input strings.

@menu
* comparators constants::       Constants definitions.
* comparators typedefs::        Type definitions.
* comparators reading::         Parsing from a string.
* comparators writing::         Writing to a string.
* comparators matching::        Matching with versions.
@end menu

@c page
@node comparators constants
@section Constants definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp Enumeration ccsemver_op_t
Type of enumeration representing the comparison criteria for comparators.
@end deftp


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_EQ
Represent the ``equality'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_LT
Represent the ``less than'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_LE
Represent the ``less than or equal to'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_GT
Represent the ``greater than'' operator.
@end deftypevr


@deftypevr {Enumerated Constant} ccsemver_op_t CCSEMVER_OP_GE
Represent the ``greater than or equal to'' operator.
@end deftypevr

@c page
@node comparators typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_comp_t
Type of @code{struct} representing parsed comparators.  Every instance of this structure is a node
in a simply--linked list.  Instances of this structure are initialised with
@cfunc{ccsemver_comp_ctor} or @cfunc{ccsemver_comp_read}.  Instances of this structure are finalised
with @cfunc{ccsemver_comp_dtor}.

It has the following public fields:

@table @code
@item ccsemver_comp_t * next
Pointer to the next comparator in the linked list; @cnull{} if this instance is the last in the
list.

@item ccsemver_op_t op
The operator specification for this comparator.

@item ccsemver_sv_t version
The version specification for this comparator.
@end table
@end deftp


@deftypefun void ccsemver_comp_ctor (ccsemver_comp_t * @var{cmp})
Initialise to empty an already allocated data structure representing a parsed comparator.  Every
call to this function must be matched by a call to @cfunc{ccsemver_comp_dtor}:

@example
ccsemver_comp_t   comp;

ccsemver_comp_ctor(&comp);
@{
  /* Do something with "comp" here. */
@}
ccsemver_comp_dtor(&comp);
@end example
@end deftypefun


@deftypefun void ccsemver_comp_dtor (ccsemver_comp_t * @var{cmp})
Finalise to empty a data structure representing a parsed comparator; calls to this function must
match a previous call to @cfunc{ccsemver_comp_ctor} or @cfunc{ccsemver_comp_read}.

All the resources associated to @var{cmp} are released, but the structure itself.  The following
code is correct:

@example
ccsemver_comp_t   comp;

ccsemver_comp_ctor(&comp);
@{
  /* Do something with "comp" here. */
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
the following code is also correct:

@example
ccsemver_comp_t * cmp;

cmp = malloc(sizeof(ccsemver_comp_t));
assert(NULL != cmp);
@{
  ccsemver_comp_ctor(cmp);
  @{
    /* Do something with "cmp" here. */
  @}
  ccsemver_comp_dtor(cmp);
@}
free(cmp);
@end example
@end deftypefun

@c page
@node comparators reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_comp_read (ccsemver_comp_t * @var{cmp}, ccsemver_input_t * @var{input})
Parse input expecting a comparator specification.  When successful: the return value is @code{0}.
If an error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{cmp}; the
structure is first initialised with @cfunc{ccsemver_comp_ctor}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_comp_dtor} to @var{cmp}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun char ccsemver_comp_and (ccsemver_comp_t * @var{cmp}, ccsemver_input_t * @var{input})
Parse input expecting a comparator specification.  When successful: the return value is @code{0}.
If an error occurs: the return value is @code{1}.

The results of parsing are appended to the already allocated and built structure referenced by
@var{cmp}.

In the unsuccessful case: the structure referenced by @var{cmp} is left untouched.

If the input is empty: the comparator is initialised as if the input is @samp{>=0.0.0}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a comparator

The following example parses the comparator specification
@samp{<=1.2.3}:

@example
static const char     input_str[] = "<=1.2.3";
ccsemver_comp_t comp;
size_t        offset = 0;
char          rv;

rv = ccsemver_comp_read(&comp, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("operation=%s, ", ccsemver_op_string(comp.op));
  ccsemver_fwrite(&comp.version, stdout);
  printf("\n");
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
and it prints:

@example
operation=CCSEMVER_OP_LE, 1.2.3
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: extending a comparator

The following example parses the comparator specification
@samp{<=1.2.3} and then extends it with @samp{<3.0.0}:

@example
static const char     input_str_1[] = ">=1.2.3";
static const char     input_str_2[] = "<3.0.0";
ccsemver_comp_t comp;
size_t        offset_1 = 0;
size_t        offset_2 = 0;
char          rv;

rv = ccsemver_comp_read(&comp, \
        input_str_1, strlen(input_str_1), &offset_1);
if (0 == rv) @{
  rv = ccsemver_comp_and(&comp, \
          input_str_2, strlen(input_str_2), &offset_2);
  if (0 == rv) @{
    for (ccsemver_comp_t * it = &comp; it; it = it->next) @{
      printf("operation=%s, ", ccsemver_op_string(it->op));
      ccsemver_fwrite(&(it->version), stdout);
      printf("\n");
    @}
    printf("comparator: ");
    ccsemver_comp_fwrite(&comp, stdout);
    printf("\n");
  @}
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
and it prints:

@example
operation=CCSEMVER_OP_GE, 1.2.3
operation=CCSEMVER_OP_LT, 3.0.0
comparator: >=1.2.3 <3.0.0
@end example

@c page
@node comparators writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_comp_write (ccsemver_comp_t const * @var{cmp}, char * @var{output_buf}, size_t @var{output_len})
Serialise the comparator @var{cmp} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full comparator serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a comparator


The following example serialises a comparator:

@example
static const char     input_str[] = "<=1.2.3";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_comp_t comp;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_comp_read(&comp, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_comp_write(&comp, \
                    buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
                       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, comp=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_comp_dtor(&comp);
@end example

@noindent
the code prints:

@example
len=7, actual_count=7, comp=<=1.2.3
@end example

@c page
@node comparators matching
@section Matching with versions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_match (ccsemver_sv_t const * @var{sv}, ccsemver_comp_t const * @var{cmp})
Match a version referenced by @var{sv} against all the comparators in the linked list referenced by
@var{cmp}.  The return value is @code{1} if the version matches; it is @code{0} otherwise.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: matching a version


The following example matches a version against a standalone comparator:

@example
const char      version_str[] = "1.2.3";
const char      compar_str[]  = ">=2.0.0";
ccsemver_sv_t      version;
ccsemver_comp_t comp;
size_t          version_off = 0, comp_off = 0;
char            rv;

rv = ccsemver_read(&version, \
        version_str, strlen(version_str), &version_off);
if (0 == rv) @{
  rv = ccsemver_comp_read(&comp, \
          compar_str, strlen(compar_str), &comp_off);
  if (0 == rv) @{
    int       result = (int)ccsemver_match(&version, &comp);
    printf("matches?=%s\n", (result)? "yes" : "no");
  @}
  ccsemver_comp_dtor(&comp);
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
matches?=no
@end example

@c page
@node ranges
@chapter Parsing and using ranges


The ranges @api{} does @strong{not} duplicate the input strings.

@menu
* ranges typedefs::             Type definitions.
* ranges reading::              Parsing from a string.
* ranges writing::              Writing to a string.
* ranges matching::             Matching ranges and versions.
@end menu

@c page
@node ranges typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_range_t
Type of @code{struct} representing parsed ranges; a range is a set of comparators.  Every instance
of this structure is a node in a simply--linked list.  Instances of this structure are initialised
with @cfunc{ccsemver_range_read}.  Instances of this structure are finalised with
@cfunc{ccsemver_range_dtor}.

It has the following public fields:

@table @code
@item ccsemver_range_t * next
Pointer to the next structure in the linked list; @cnull{} if this instance is the last in the list.

@item ccsemver_comp_t comp
A version comparator.
@end table
@end deftp


@deftypefun void ccsemver_range_dtor (ccsemver_range_t * @var{rn})
Finalise to empty a data structure representing a parsed range; calls to this function must match a
previous call to @cfunc{ccsemver_range_read}.

All the resources associated to @var{rn} are released, but the structure itself.  The following code
is correct:

@example
ccsemver_range_t  range;

ccsemver_range_read(&range, ...);
@{
  /* Do something with "range" here. */
@}
ccsemver_range_dtor(&range);
@end example

@noindent
the following code is also correct:

@example
ccsemver_range_t * rn;

rn = malloc(sizeof(ccsemver_range_t));
assert(NULL != rn);
@{
  ccsemver_range_read(&range, ...);
  @{
    /* Do something with "rn" here. */
  @}
  ccsemver_range_dtor(rn);
@}
free(rn);
@end example
@end deftypefun

@c page
@node ranges reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_range_read (ccsemver_range_t * @var{rn}, ccsemver_input_t * @var{input})
Parse input expecting a range specification.  When successful: the return value is @code{0}.  If an
error occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{rn}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_range_dtor} to @var{rn}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a range

The following example parses the range specification @samp{1.2.7 || >=1.2.9 <2.0.0}:

@example
static const char  input_str[] = "1.2.7 || >=1.2.9 <2.0.0";
ccsemver_range_t     range;
size_t             offset = 0;
char               rv;

rv = ccsemver_range_read(&range, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("range: ");
  ccsemver_range_fwrite(&range, stdout);
  printf("\n");
@}
ccsemver_range_dtor(&range);
@end example

@noindent
and it prints:

@example
range: 1.2.7 || >=1.2.9 <2.0.0
@end example

@c page
@node ranges writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_range_write (ccsemver_range_t const * @var{rn}, char * @var{output_buf}, size_t @var{output_len})
Serialise the range @var{rn} as @ascii{} string in the memory block referenced by @var{output_buf},
which has at least @var{output_len} characters available.  If the buffer has not enough room to hold
the full comparator serialisation: the string is truncated to @var{output_len} characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising a range


The following example serialises a range:

@example
static const char     input_str[] = \
   "1.2.7 || >=1.2.9 <2.0.0";
size_t                buffer_len = 32;
char                  buffer_ptr[buffer_len];
ccsemver_range_t        range;
size_t                offset = 0;
char                  rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_range_read(&range, \
        input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_range_write(&range, \
     buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, range=",
           strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_range_dtor(&range);
@end example

@noindent
the code prints:

@example
len=23, actual_count=23, range=1.2.7 || >=1.2.9 <2.0.0
@end example

@c page
@node ranges matching
@section Matching ranges and versions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_range_match (ccsemver_sv_t const * @var{sv}, ccsemver_range_t const * @var{rangep})
Match a version referenced by @var{sv} against the comparators in the range referenced by
@var{rangep}.  The return value is @code{1} if the version matches at least one comparator; it is
@code{0} otherwise.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: matching a version


The following example matches a version against a range:

@example
static const char     version_str[] = "1.4.6";
static const char     range_str[]  = "1.2.7 || >=1.2.9 <2.0.0";
ccsemver_sv_t              version;
ccsemver_range_t        range;
size_t                version_off = 0, range_off = 0;
char                  rv;

rv = ccsemver_read(&version, \
        version_str, strlen(version_str), &version_off);
if (0 == rv) @{
  rv = ccsemver_range_read(&range, \
          range_str, strlen(range_str), &range_off);
  if (0 == rv) @{
    int       result = (int)ccsemver_range_match(&version, &range);
    printf("matches?=%s\n", (result)? "yes" : "no");
  @}
  ccsemver_range_dtor(&range);
@}
ccsemver_dtor(&version);
@end example

@noindent
the code prints:

@example
matches?=yes
@end example

@c page
@node numbers
@chapter Parsing numbers and numeric components


In the context of @value{PACKAGE}'s parsing functions, @dfn{numeric components} are @ascii{} strings
holding: numeric characters (according to the standard function @cfunc{isdigit}); the standalone
character @samp{x}; the standalone character @samp{X}; the standalone character @samp{*}.

Usually we do @strong{not} need to use the numeric components parser directly.

All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_parse_number (long * @var{nump}, ccsemver_input_t * @var{input})
Parse input expecting plain number.  When successful: the return value is @code{0}.  If an error
occurs: the return value is @code{1}.

The results of parsing are stored in the variable referenced by @var{nump}.

The following example code parses a numeric component:

@example
char const *    input_str = "123";
size_t          input_len = strlen(input_str);
long            num;
size_t          input_off = 0;
char            rv;

rv = ccsemver_parse_number(&num, input_str, input_len, &input_off);
if (0 == rv) @{
  printf("num=%ld\n", num);
@}
@end example
@end deftypefun


@deftypefun char ccsemver_num_parse (long * @var{nump}, ccsemver_input_t * @var{input})
Parse input expecting a numeric component.  When successful: the return value is @code{0}.  If an
error occurs: the return value is @code{1}.

The results of parsing are stored in the variable referenced by @var{nump}.

If the input string contains @samp{x}, @samp{X} or @samp{*}: the function returns successfully and
stores the value @code{CCSEMVER_NUM_X} in the variable referenced by @var{nump}.

The following example code parses a numeric component:

@example
char const *    input_str = "123";
size_t          input_len = strlen(input_str);
long            num;
size_t          input_off = 0;
char            rv;

rv = ccsemver_num_parse(&num, input_str, input_len, &input_off);
if (0 == rv) @{
  printf("num=%ld\n", num);
@}
@end example
@end deftypefun


@deftypevr {Preprocessor Symbol} long CCSEMVER_NUM_X
Special value used to represent a numeric component specified as @samp{x}, @samp{X} or @samp{*}.
@end deftypevr


@deftypefun int ccsemver_num_comp (long @var{A}, long @var{B})
Compare the given integers.  Return @code{-1} if @var{A} is less than @var{B}; return @code{0} if
@var{A} is equal to @var{B}; return @code{+1} if @var{A} is greater than @var{B}.

The return values of this function are @strong{invalid} if one of the arguments is
@code{CCSEMVER_NUM_X}.
@end deftypefun

@c page
@node identifiers
@chapter Parsing identifiers


In the context of @value{PACKAGE}'s parsing functions, identifiers are @ascii{} strings holding:
alphanumeric characters (according to the standard function @cfunc{isalnum}); dash characters; dot
characters.  Dot characters are interpreted as separators between components; a plus character is
interpreted as ending character for an identifier.

The semantic version string:

@example
1.2.3-alpha.7+x86-64
@end example

@noindent
contains as ``prerelease tag'' the identifier:

@example
alpha.7
@end example

@noindent
which is represented as a linked list of two instances of @objtype{ccsemver_id_t}; the first
instance references the identifier component @samp{alpha}; the second instance references the
identifier component @samp{7}.

Usually we do @strong{not} need to use the identifiers parser directly.

@menu
* identifiers typedefs::        Type definitions.
* identifiers reading::         Parsing from a string.
* identifiers writing::         Writing to a string.
* identifiers comparing::       Identifiers comparison.
@end menu

@c page
@node identifiers typedefs
@section Type definitions


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftp {Struct Typedef} ccsemver_id_t
Type of @code{struct} representing a single component in a parsed identifier; every instance of this
structure is a node in a simply--linked list.  The identifiers @api{} does @strong{not} duplicate
the input strings.  Instances of this structure are initialised with @cfunc{ccsemver_id_ctor} or
@cfunc{ccsemver_id_read}.  Instances of this structure are finalised with @cfunc{ccsemver_id_dtor}.

The structure has the following public fields:

@table @code
@item bool numeric
A boolean value: @ctrue{} if the this component is numeric; @cfalse{} if this component is
alphabetic.

@item long num
If this component is numeric: this field holds its numeric representation.  Otherwise this field
holds a meaningless value.

@item size_t len
The number of characters in the input string that where parsed to form this component.

@item const char * raw
Pointer to the character in the input string representing the first character of this component.
This pointer is valid as long as the input string handed to @cfunc{ccsemver_id_read} is not mutated.

@item ccsemver_id_t * next
Pointer to the next node in the linked list; @cnull{} if this structure is the last node.
@end table
@end deftp


@deftypefun void ccsemver_id_ctor (ccsemver_id_t * @var{id})
Initialise to empty an already allocated data structure representing a parsed identifier.  Every
call to this function must be matched by a call to @cfunc{ccsemver_id_dtor}:

@example
ccsemver_id_t     id;

ccsemver_id_ctor(&id);
@{
  /* Do something with "id" here. */
@}
ccsemver_id_dtor(&id);
@end example
@end deftypefun


@deftypefun void ccsemver_id_dtor(ccsemver_id_t * @var{id})
Finalise to empty a data structure representing a parsed identifier; calls to this function must
match a previous call to @cfunc{ccsemver_id_ctor} or @cfunc{ccsemver_id_read}.

All the resources associated to @var{id} are released, but the structure itself.  The following
code is correct:

@example
ccsemver_id_t     id;

ccsemver_id_ctor(&id);
@{
  /* Do something with "id" here. */
@}
ccsemver_id_dtor(&id);
@end example

@noindent
the following code is also correct:

@example
ccsemver_id_t *   id;

id = malloc(sizeof(ccsemver_id_t));
assert(NULL != id);
@{
  ccsemver_id_ctor(id);
  @{
    /* Do something with "id" here. */
  @}
  ccsemver_id_dtor(id);
@}
free(id);
@end example
@end deftypefun

@c page
@node identifiers reading
@section Parsing from a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_id_read (ccsemver_id_t * @var{id}, ccsemver_input_t * @var{input})
Parse input expecting an identifier.  When successful: the return value is @code{0}.  If an error
occurs: the return value is @code{1}.

The results of parsing are stored in the already allocated structure referenced by @var{id}; the
structure is first initialised with @cfunc{ccsemver_id_ctor}.

In both the successful and unsuccessful cases: every call to this function must be matched by the
application of @cfunc{ccsemver_id_dtor} to @var{id}.

Internally, this function allocates memory with @cfunc{malloc}; if memory allocation fails: the
return value is @code{1}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a numeric identifier

The following example parses the numeric identifier @samp{123}:

@example
static const char     input_str[] = "123";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("numeric?=%d, num=%ld, len=%lu, raw=%s, next=%p\n",
         (int)id.numeric, id.num, id.len, id.raw,
         (void *)id.next);
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=1, num=123, len=3, raw=123, next=(nil)
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing an alphabetic identifier

The following example parses the alphabetic identifier @samp{alpha}:

@example
static const char     input_str[] = "alpha";
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  printf("numeric?=%d, num=%ld, len=%lu, raw=%s, next=%p\n",
         (int)id.numeric, id.num, id.len, id.raw,
         (void *)id.next);
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha, next=(nil)
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a compound identifier


The following example parses the compound identifier @samp{1.2.3-alpha.7}:

@example
const char     input_str[] = "1.2.3-alpha.7";
ccsemver_id_t  id;
size_t         offset = 6;
char           rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  for (ccsemver_id_t * iter = &id; iter; iter = iter->next) @{
    printf("numeric?=%d, num=%ld, len=%lu, raw=%s\n",
           (int)iter->numeric, iter->num, iter->len, iter->raw);
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha.7
numeric?=1, num=7, len=1, raw=7
@end example

@c ------------------------------------------------------------------------

@subsubheading Example: parsing a compound identifier with appended build metadata


The following example parses the compound identifier @samp{1.2.3-alpha.7+x86-64}:

@example
const char     input_str[] = "1.2.3-alpha.7+x86-64";
ccsemver_id_t  id;
size_t         offset = 6;
char           rv;

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  for (ccsemver_id_t * iter = &id; iter; iter = iter->next) @{
    printf("numeric?=%d, num=%ld, len=%lu, raw=%s\n",
           (int)iter->numeric, iter->num, iter->len, iter->raw);
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
and it prints:

@example
numeric?=0, num=0, len=5, raw=alpha.7+x86-64
numeric?=1, num=7, len=1, raw=7+x86-64
@end example

@noindent
notice how parsing the identifier stops at the character @samp{+}, which delimits the beginning of
the build metadata.

@c page
@node identifiers writing
@section Writing to a string


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun int ccsemver_id_write (ccsemver_id_t const * @var{id}, char * @var{output_buf}, size_t @var{output_len})
Serialise the identifier @var{id} as @ascii{} string in the memory block referenced by
@var{output_buf}, which has at least @var{output_len} characters available.  If the buffer has not
enough room to hold the full identifier serialisation: the string is truncated to @var{output_len}
characters.

Like @cfunc{snprintf}: return the number of characters needed to hold the full serialisation,
excluding the trailing null; if the return value is greater than or equal to @var{output_len}, the
string has been truncated.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: serialising an identifier


The following example serialises a compound identifier:

@example
static const char     input_str[] = "1.2.3-alpha.7";
size_t        buffer_len = 32;
char          buffer_ptr[buffer_len];
ccsemver_id_t   id;
size_t        offset = 0;
char          rv;

memset(buffer_ptr, 0, buffer_len);

rv = ccsemver_id_read(&id, input_str, strlen(input_str), &offset);
if (0 == rv) @{
  size_t      needed_count;
  size_t      actual_count;
  needed_count = (size_t)ccsemver_id_write(&id, \
      buffer_ptr, buffer_len);
  if (0 < needed_count) @{
    actual_count = (needed_count < buffer_len)? \
       needed_count : buffer_len;
    printf("len=%lu, actual_count=%lu, id=",
      strlen(input_str), actual_count);
    fwrite(buffer_ptr, sizeof(char), actual_count, stdout);
    printf("\n");
  @}
@}
ccsemver_id_dtor(&id);
@end example

@noindent
the code prints:

@example
len=13, actual_count=13, id=1.2.3-alpha.7
@end example

@c page
@node identifiers comparing
@section Identifiers comparison


All the following symbols are defined in the header file @file{ccsemver.h}.


@deftypefun char ccsemver_id_comp (ccsemver_id_t const * @vari{id}, ccsemver_id_t const * @varii{id})
Compare the numeric components of the given identifiers.  Return @code{-1} if @vari{id} is less than
@varii{id}; return @code{0} if @vari{id} is equal to @varii{id}; return @code{+1} if @vari{id} is
greater than @varii{id}.

An empty identifier is less than any other identifier but the empty one; two empty identifiers are
equal.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example: comparing identifiers


The following example compares two identifiers:

@example
static const char     input_str_A[] = "1.2.3";
static const char     input_str_B[] = "1.2.4";
ccsemver_id_t   id_A, id_B;
size_t        offset_A = 0, offset_B = 0;
char          rv;

rv = ccsemver_id_read(&id_A, \
    input_str_A, strlen(input_str_A), &offset_A);
if (0 == rv) @{
  rv = ccsemver_id_read(&id_B, \
      input_str_B, strlen(input_str_B), &offset_B);
  if (0 == rv) @{
    char    compar = ccsemver_id_comp(&id_A, &id_B);
    printf("compar=%d\n", (int)compar);
  @}
  ccsemver_id_dtor(&id_B);
@}
ccsemver_id_dtor(&id_A);
@end example

@noindent
and the code prints:

@example
compar=-1
@end example

@c page
@node utilities
@chapter Utility functions


All the following symbols are defined in the header file
@file{ccsemver.h}.


@deftypefun size_t ccsemver_id_fwrite (const ccsemver_id_t * @var{id}, FILE * @var{stream})
Serialise the referenced identifier to the given @var{stream}.  When successful: return the number
of characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_sv_fwrite (const ccsemver_sv_t * @var{sv}, FILE * @var{stream})
Serialise the referenced version to the given @var{stream}.  When successful: return the number of
characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_comp_fwrite (const ccsemver_comp_t * @var{cmp}, FILE * @var{stream})
Serialise the referenced comparator to the given @var{stream}.  When successful: return the number
of characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun size_t ccsemver_range_fwrite (const ccsemver_range_t * @var{rn}, FILE * @var{stream})
Serialise the referenced range to the given @var{stream}.  When successful: return the number of
characters written and clear @code{errno} to zero.  If an error occurs: set @code{errno} to an
appropriate error code.
@end deftypefun


@deftypefun {char const *} ccsemver_op_string (ccsemver_op_t @var{op})
Return a statically allocated @asciiz{} string representing the name of @var{op}.  Useful for
debugging purposes.
@end deftypefun

@c page
@node Package License
@appendix Unlicense


This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in
source code form or as a compiled binary, for any purpose, commercial or non--commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any
and all copyright interest in the software to the public domain. We make this dedication for the
benefit of the public at large and to the detriment of our heirs and successors. We intend this
dedication to be an overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to @url{http://unlicense.org}.

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCStructs is available at:

@center @url{https://github.com/marcomaggi/ccstructs/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

This package is a fork of the project Libsv by @value{ORIGIN_AUTHOR}; the original project is
available at:

@center @value{OriginUrl}

The specification of Semantic Versioning is publicly available at the site:

@center @url{https://semver.org/}

@noindent
under the terms of the @url{https://creativecommons.org/licenses/by/3.0/, Creative Commons --- CC BY
3.0}.  The @emph{Semantic Versioning} specification is authored by Tom Preston--Werner, inventor of
Gravatars and cofounder of GitHub.  @value{PACKAGE} implements a parser for version 2.0.0 of the

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
